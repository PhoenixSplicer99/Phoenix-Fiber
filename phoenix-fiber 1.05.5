<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phoenix Fiber - Next Generation Fiber Management</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <!-- Add SheetJS for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #FF6B35;
            --primary-dark: #DC2626;
            --primary-light: #FFB700;
            --secondary: #1e293b;
            --surface: #ffffff;
            --surface-2: #f8fafc;
            --surface-3: #f1f5f9;
            --border: #e2e8f0;
            --text: #334155;
            --text-light: #64748b;
            --success: #10b981;
            --info: #3b82f6;
            --warning: #f59e0b;
            --error: #ef4444;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --radius: 0.75rem;
            --radius-sm: 0.5rem;
            --radius-lg: 1rem;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--surface-2);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Modern Header */
        .header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
        }
        
        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--secondary);
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary) 50%, var(--primary-dark) 100%);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        /* Tab Navigation */
        .nav-tabs {
            display: flex;
            gap: 0.5rem;
            background: var(--surface-3);
            padding: 0.25rem;
            border-radius: var(--radius);
        }
        
        .nav-tab {
            padding: 0.5rem 1.5rem;
            background: none;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .nav-tab:hover {
            color: var(--text);
        }
        
        .nav-tab.active {
            background: var(--surface);
            color: var(--primary);
            box-shadow: var(--shadow-sm);
        }
        
        /* Main Layout */
        .main-container {
            margin-top: 73px;
            height: calc(100vh - 73px);
            display: flex;
            flex-direction: column;
        }
        
        /* Content Panels */
        .content-panel {
            display: none;
            height: 100%;
        }
        
        .content-panel.active {
            display: flex;
            flex-direction: column;
        }
        
        /* Data Input Panel */
        .data-input-panel {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }
        
        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        
        .input-grid-3col {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }
        
        @media (max-width: 1024px) {
            .input-grid, .input-grid-3col {
                grid-template-columns: 1fr;
            }
        }
        
        .input-section {
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .input-header {
            background: var(--surface-2);
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .input-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        .input-subtitle {
            font-size: 0.875rem;
            color: var(--text-light);
        }
        
        /* Excel-like Grid */
        .grid-toolbar {
            background: var(--surface);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .grid-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .grid-btn {
            padding: 0.375rem 0.75rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }
        
        .grid-btn:hover {
            background: var(--surface-3);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .grid-wrapper {
            flex: 1;
            overflow: auto;
            background: var(--surface);
        }
        
        .data-grid {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }
        
        .data-grid th {
            position: sticky;
            top: 0;
            background: var(--surface-3);
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: var(--text);
            border-bottom: 2px solid var(--border);
            z-index: 10;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }
        
        .data-grid th:hover {
            background: var(--surface-2);
            color: var(--primary);
        }
        
        .data-grid th.sorting-asc::after {
            content: ' ↑';
            color: var(--primary);
            font-size: 0.875rem;
        }
        
        .data-grid th.sorting-desc::after {
            content: ' ↓';
            color: var(--primary);
            font-size: 0.875rem;
        }
        
        .data-grid th.row-number-header {
            width: 50px;
            text-align: center;
            background: var(--surface-2);
        }
        
        .data-grid td {
            padding: 0;
            border-bottom: 1px solid var(--border);
            border-right: 1px solid var(--border);
        }
        
        .data-grid tr:hover {
            background: var(--surface-2);
        }
        
        .data-grid td.row-number {
            width: 50px;
            text-align: center;
            padding: 0.5rem;
            background: var(--surface-2);
            font-weight: 500;
            color: var(--text-light);
        }
        
        .grid-input {
            width: 100%;
            height: 100%;
            padding: 0.5rem 0.75rem;
            border: none;
            font-size: 0.875rem;
            font-family: inherit;
            background: transparent;
            color: var(--text);
        }
        
        .grid-input:focus {
            outline: none;
            background: var(--surface-2);
            box-shadow: inset 0 0 0 2px var(--primary);
        }
        
        .grid-input.valid {
            background: #f0fdf4;
        }
        
        .grid-input.error {
            background: #fef2f2;
        }
        
        /* Detection Status */
        .detection-status {
            padding: 1rem;
            background: var(--surface-2);
            border-top: 1px solid var(--border);
            display: none;
        }
        
        .detection-status.show {
            display: block;
        }
        
        .detection-alert {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(to right, #dbeafe, #e0f2fe);
            border: 1px solid #60a5fa;
            border-radius: var(--radius-sm);
            color: #1e40af;
        }
        
        .detection-icon {
            font-size: 1.25rem;
        }
        
        .detection-content {
            flex: 1;
        }
        
        .detection-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .detection-description {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        
        .detection-action {
            padding: 0.5rem 1rem;
            background: var(--info);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .detection-action:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        /* Map Panel */
        .map-panel {
            position: relative;
            height: 100%;
        }
        
        #networkMap {
            width: 100%;
            height: 100%;
        }
        
        /* Floating Panels */
        .floating-panel {
            position: absolute;
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            max-width: 90%;
        }
        
        .panel-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
        }
        
        .panel-close {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            background: var(--surface-2);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-light);
        }
        
        .panel-close:hover {
            background: var(--surface-3);
            color: var(--text);
        }
        
        /* Network Stats Panel */
        .stats-panel {
            top: 1.5rem;
            left: 1.5rem;
            width: 320px;
        }
        
        .stats-grid {
            padding: 1.5rem;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        .stat-card {
            padding: 1rem;
            background: var(--surface-2);
            border-radius: var(--radius-sm);
            text-align: center;
        }
        
        .stat-card:last-child {
            grid-column: 1 / -1;
        }
        
        .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--primary);
            line-height: 1;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 0.25rem;
        }
        
        /* Search Panel */
        .search-panel {
            top: 1.5rem;
            right: 1.5rem;
            width: 320px;
        }
        
        .search-input-wrapper {
            padding: 1rem;
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
        }
        
        .search-icon {
            position: absolute;
            left: 1.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-light);
        }
        
        .search-results {
            max-height: 400px;
            overflow-y: auto;
            padding: 0 1rem 1rem;
        }
        
        .search-result {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--surface-2);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .search-result:hover {
            background: var(--surface-3);
            transform: translateX(4px);
        }
        
        .search-result-title {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 0.25rem;
        }
        
        .search-result-details {
            font-size: 0.75rem;
            color: var(--text-light);
        }
        
        /* Legend */
        .legend-panel {
            bottom: 1.5rem;
            left: 1.5rem;
            padding: 1rem;
        }
        
        .legend-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.75rem;
        }
        
        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
            color: var(--text-light);
        }
        
        .legend-line {
            width: 24px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-marker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .legend-square {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        /* Map Controls */
        .map-controls {
            position: absolute;
            top: 50%;
            right: 1.5rem;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .map-control {
            width: 40px;
            height: 40px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
            box-shadow: var(--shadow);
        }
        
        .map-control:hover {
            background: var(--surface-2);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        /* Enhanced Map Toolbar - Centralized Command Center */
        .map-toolbar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 1000;
            max-width: 90%;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .toolbar-section {
            display: flex;
            gap: 0.5rem;
            padding: 0 0.5rem;
            border-right: 1px solid var(--border);
        }
        
        .toolbar-section:last-child {
            border-right: none;
        }
        
        .toolbar-section-label {
            font-size: 0.625rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            align-self: center;
            margin-right: 0.5rem;
            font-weight: 600;
        }
        
        .map-tool {
            padding: 0.5rem 1rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            white-space: nowrap;
        }
        
        .map-tool:hover {
            background: var(--surface-3);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .map-tool.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .map-tool.icon-only {
            padding: 0.5rem;
            min-width: 36px;
            justify-content: center;
        }
        
        .map-tool.icon-only span:last-child {
            display: none;
        }
        
        @media (max-width: 1200px) {
            .map-tool span:last-child {
                display: none;
            }
            .map-tool {
                padding: 0.5rem;
                min-width: 36px;
                justify-content: center;
            }
            .toolbar-section-label {
                display: none;
            }
        }
        
        /* Path Trace Panel */
        .path-trace-panel {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            padding: 1.5rem;
            width: 400px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .path-trace-panel.show {
            display: block;
        }
        
        .path-trace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .path-segment {
            background: var(--surface-2);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .path-segment-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .path-segment-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            font-size: 0.75rem;
        }
        
        /* Network Path Visualization */
        .network-path {
            stroke: var(--primary);
            stroke-width: 4;
            fill: none;
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }
        
        /* GEM Fiber Status */
        .gem-status {
            padding: 1rem;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: none;
        }
        
        .gem-status.show {
            display: block;
        }
        
        .gem-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(to right, #f0fdf4, #dcfce7);
            border: 1px solid #22c55e;
            border-radius: var(--radius-sm);
            color: #166534;
        }
        
        .gem-info-content {
            flex: 1;
        }
        
        .gem-info-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .gem-info-details {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        
        /* Process Button */
        .process-section {
            padding: 2rem;
            text-align: center;
        }
        
        .process-btn {
            padding: 0.75rem 2rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-md);
        }
        
        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .process-btn:disabled {
            background: var(--text-light);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Loading State */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 100px;
            right: 2rem;
            background: var(--success);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            transform: translateX(400px);
            transition: transform 0.3s ease-out;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-icon {
            font-size: 1.25rem;
        }
        
        .notification-content {
            flex: 1;
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 0.125rem;
        }
        
        .notification-message {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        
        /* Splice Documentation Styles */
        .splicing-panel {
            padding: 2rem;
            overflow-y: auto;
        }
        
        .splicing-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .splice-doc-header {
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
        }
        
        .splice-doc-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .export-btn {
            padding: 0.75rem 1.5rem;
            background: var(--info);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .export-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        /* Splice Sheet Preview */
        .splice-sheet-preview {
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            page-break-inside: avoid;
        }
        
        .sheet-header {
            border-bottom: 2px solid var(--border);
            padding-bottom: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .company-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .company-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .document-info {
            text-align: right;
            font-size: 0.875rem;
            color: var(--text-light);
        }
        
        .sheet-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--secondary);
            text-align: center;
            margin-top: 1rem;
        }
        
        .splice-matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            margin-top: 1rem;
        }
        
        .splice-matrix-table th {
            background: var(--surface-3);
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            border: 1px solid var(--border);
            color: var(--secondary);
        }
        
        .splice-matrix-table td {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
        }
        
        .splice-matrix-table tr:hover {
            background: var(--surface-2);
        }
        
        /* LGX Panel Visualization */
        .lgx-panel {
            position: absolute;
            top: 80px;
            left: 1.5rem;
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            width: 400px;
            z-index: 1000;
            display: none;
        }
        
        .lgx-panel.show {
            display: block;
        }
        
        .lgx-panel-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .lgx-panel-content {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .lgx-port-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 2px;
            padding: 1rem;
        }
        
        .lgx-port {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem;
            font-weight: 600;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border);
        }
        
        .lgx-port.assigned {
            background: var(--primary);
            color: white;
            border-color: var(--primary-dark);
        }
        
        .lgx-port.unassigned {
            background: var(--text-light);
            color: white;
            opacity: 0.6;
        }
        
        .lgx-port:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        /* Customer Trace Panel */
        .customer-trace-panel {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            padding: 1rem;
            z-index: 1000;
            display: none;
        }
        
        .customer-trace-panel.show {
            display: block;
        }
        
        .customer-trace-input {
            display: flex;
            gap: 0.5rem;
        }
        
        .customer-input {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
        }
        
        .trace-btn {
            padding: 0.5rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .trace-btn:hover {
            background: var(--primary-dark);
        }
        
        /* Hierarchy View Toggle */
        .hierarchy-toggle {
            position: absolute;
            bottom: 120px;
            left: 1.5rem;
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 0.5rem;
            box-shadow: var(--shadow-xl);
            z-index: 1000;
        }
        
        .hierarchy-btn {
            padding: 0.5rem 1rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 0.25rem;
        }
        
        .hierarchy-btn:hover {
            background: var(--surface-3);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .hierarchy-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        /* Snapped connection indicators */
        .snap-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--success);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: var(--shadow-md);
            animation: pulse 2s infinite;
            z-index: 1005;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Splice Connection Status */
        .splice-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }
        
        .splice-status.connected {
            background: var(--success);
            color: white;
        }
        
        .splice-status.pending {
            background: var(--warning);
            color: white;
        }
        
        .splice-status.disconnected {
            background: var(--error);
            color: white;
        }
        
        /* Smart Paste Dialog Styles */
        .smart-paste-dialog select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        .smart-paste-dialog button:hover {
            transform: translateY(-1px);
        }
        
        .smart-paste-dialog button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">🔥</div>
                <span>Phoenix Fiber</span>
            </div>
            
            <nav class="nav-tabs">
                <button class="nav-tab active" data-tab="input">
                    <span>📊 Data Input</span>
                </button>
                <button class="nav-tab" data-tab="map">
                    <span>🗺️ Network Map</span>
                </button>
                <button class="nav-tab" data-tab="splicing">
                    <span>📄 Splicing Docs</span>
                </button>
                <button class="nav-tab" data-tab="analysis">
                    <span>📈 Analysis</span>
                </button>
            </nav>
            
            <div class="header-actions">
                <button class="grid-btn" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)">
                    <span>↶</span> Undo
                </button>
                <button class="grid-btn" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)">
                    <span>↷</span> Redo
                </button>
                <button class="grid-btn" onclick="loadProject()">
                    <span>📂</span> Load Project
                </button>
                <button class="grid-btn" style="background: var(--primary); color: white; border-color: var(--primary);" onclick="saveProject()">
                    <span>💾</span> Save Project
                </button>
            </div>
        </div>
    </header>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Data Input Panel -->
        <div class="content-panel active" id="input-panel">
            <div class="data-input-panel">
                <div class="input-grid">
                    <!-- Cable Data Input -->
                    <div class="input-section">
                        <div class="input-header">
                            <h2 class="input-title">📡 Cable Data</h2>
                            <p class="input-subtitle">Paste your cable data from QGIS or enter manually</p>
                        </div>
                        
                        <div class="detection-status" id="spliceGeoStatus">
                            <div class="detection-alert">
                                <span class="detection-icon">📍</span>
                                <div class="detection-content">
                                    <div class="detection-title">Splice locations detected!</div>
                                    <div class="detection-description">Splice points with location data ready for mapping</div>
                                </div>
                                <button class="detection-action" onclick="processData()">
                                    View on Map
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid-toolbar">
                            <div class="grid-actions">
                                <button class="grid-btn" onclick="clearCableGrid()">
                                    <span>🗑️</span> Clear
                                </button>
                                <button class="grid-btn" onclick="addCableRows(5)">
                                    <span>➕</span> Add Rows
                                </button>
                                <button class="grid-btn" onclick="loadCableSample()">
                                    <span>📋</span> Sample
                                </button>
                                <div style="display: inline-flex; gap: 0.25rem; margin-left: 1rem; padding-left: 1rem; border-left: 1px solid var(--border);">
                                    <button class="grid-btn" onclick="quickFilterCableType('ALL')" title="Show all cables">All</button>
                                    <button class="grid-btn" onclick="quickFilterCableType('FEEDER')" title="Show only FEEDER cables">Feeder</button>
                                    <button class="grid-btn" onclick="quickFilterCableType('DISTRIBUTION')" title="Show only DISTRIBUTION cables">Dist</button>
                                    <button class="grid-btn" onclick="quickFilterCableType('MST TAIL')" title="Show only MST TAIL cables">Tail</button>
                                </div>
                            </div>
                            <div class="grid-info">
                                <span id="cableRowCount">0 rows</span>
                            </div>
                        </div>
                        
                        <div class="grid-wrapper">
                            <table class="data-grid" id="cableGrid">
                                <thead>
                                    <tr>
                                        <th class="row-number-header">#</th>
                                        <th onclick="sortTable('cableGrid', 1)" data-sort-type="text">cable_type</th>
                                        <th onclick="sortTable('cableGrid', 2)" data-sort-type="text">fondid</th>
                                        <th onclick="sortTable('cableGrid', 3)" data-sort-type="number">size</th>
                                        <th onclick="sortTable('cableGrid', 4)" data-sort-type="text">cable_ct</th>
                                        <th onclick="sortTable('cableGrid', 5)" data-sort-type="text" style="min-width: 200px;">wkt_geom <span style="font-weight: normal; color: var(--text-light);">(optional)</span></th>
                                    </tr>
                                </thead>
                                <tbody id="cableGridBody">
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="detection-status" id="cableGeoStatus">
                            <div class="detection-alert">
                                <span class="detection-icon">🌍</span>
                                <div class="detection-content">
                                    <div class="detection-title">Geographic data detected!</div>
                                    <div class="detection-description">Cables with location data ready for mapping</div>
                                </div>
                                <button class="detection-action" onclick="processData()">
                                    View on Map
                                </button>
                            </div>
                        </div>
                        
                        <div class="gem-status" id="gemStatus">
                            <div class="gem-info">
                                <span class="detection-icon">⚡</span>
                                <div class="gem-info-content">
                                    <div class="gem-info-title">GEM Fiber Processing Active</div>
                                    <div class="gem-info-details" id="gemDetails">Light source cable identified</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Splice Data Input -->
                    <div class="input-section">
                        <div class="input-header">
                            <h2 class="input-title">🔌 Splice Points</h2>
                            <p class="input-subtitle">Paste your splice point data from QGIS or enter manually</p>
                        </div>
                        
                        <div class="grid-toolbar">
                            <div class="grid-actions">
                                <button class="grid-btn" onclick="clearSpliceGrid()">
                                    <span>🗑️</span> Clear
                                </button>
                                <button class="grid-btn" onclick="addSpliceRows(5)">
                                    <span>➕</span> Add Rows
                                </button>
                                <button class="grid-btn" onclick="loadSpliceSample()">
                                    <span>📋</span> Sample
                                </button>
                                <select id="spliceFdaFilter" onchange="filterSplicesByFDA()" style="margin-left: 1rem; padding: 0.375rem 0.75rem; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 0.75rem;">
                                    <option value="">All FDAs</option>
                                    <option value="VAAUGS0204">VAAUGS0204</option>
                                    <option value="VAAUGS0207">VAAUGS0207</option>
                                </select>
                            </div>
                            <div class="grid-info">
                                <span id="spliceRowCount">0 rows</span>
                            </div>
                        </div>
                        
                        <div class="grid-wrapper">
                            <table class="data-grid" id="spliceGrid">
                                <thead>
                                    <tr>
                                        <th class="row-number-header">#</th>
                                        <th onclick="sortTable('spliceGrid', 1)" data-sort-type="text">fondid</th>
                                        <th onclick="sortTable('spliceGrid', 2)" data-sort-type="text">fda</th>
                                        <th onclick="sortTable('spliceGrid', 3)" data-sort-type="text">fsa</th>
                                        <th onclick="sortTable('spliceGrid', 4)" data-sort-type="text">placement</th>
                                        <th onclick="sortTable('spliceGrid', 5)" data-sort-type="text">spec</th>
                                        <th onclick="sortTable('spliceGrid', 6)" data-sort-type="text">ap_type</th>
                                        <th onclick="sortTable('spliceGrid', 7)" data-sort-type="text" style="min-width: 200px;">wkt_geom <span style="font-weight: normal; color: var(--text-light);">(optional)</span></th>
                                    </tr>
                                </thead>
                                <tbody id="spliceGridBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- Additional Data Inputs -->
                <div class="input-grid-3col">
                    <!-- Cabinets Input -->
                    <div class="input-section">
                        <div class="input-header">
                            <h2 class="input-title">🏭 Cabinets</h2>
                            <p class="input-subtitle">Active & Passive Cabinets</p>
                        </div>
                        
                        <div class="grid-toolbar">
                            <div class="grid-actions">
                                <button class="grid-btn" onclick="clearCabinetGrid()">
                                    <span>🗑️</span> Clear
                                </button>
                                <button class="grid-btn" onclick="addCabinetRows(5)">
                                    <span>➕</span> Add Rows
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid-wrapper">
                            <table class="data-grid" id="cabinetGrid">
                                <thead>
                                    <tr>
                                        <th class="row-number-header">#</th>
                                        <th onclick="sortTable('cabinetGrid', 1)" data-sort-type="text">cabinet_id</th>
                                        <th onclick="sortTable('cabinetGrid', 2)" data-sort-type="text">type</th>
                                        <th onclick="sortTable('cabinetGrid', 3)" data-sort-type="number">cab_size</th>
                                        <th onclick="sortTable('cabinetGrid', 4)" data-sort-type="text">fsa</th>
                                        <th onclick="sortTable('cabinetGrid', 5)" data-sort-type="text">fda</th>
                                        <th onclick="sortTable('cabinetGrid', 6)" data-sort-type="text">spec</th>
                                        <th onclick="sortTable('cabinetGrid', 7)" data-sort-type="text">wkt_geom</th>
                                    </tr>
                                </thead>
                                <tbody id="cabinetGridBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- MST Input -->
                    <div class="input-section">
                        <div class="input-header">
                            <h2 class="input-title">📟 MST Hubs</h2>
                            <p class="input-subtitle">Multi-Service Terminals</p>
                        </div>
                        
                        <div class="grid-toolbar">
                            <div class="grid-actions">
                                <button class="grid-btn" onclick="clearMSTGrid()">
                                    <span>🗑️</span> Clear
                                </button>
                                <button class="grid-btn" onclick="addMSTRows(5)">
                                    <span>➕</span> Add Rows
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid-wrapper">
                            <table class="data-grid" id="mstGrid">
                                <thead>
                                    <tr>
                                        <th class="row-number-header">#</th>
                                        <th onclick="sortTable('mstGrid', 1)" data-sort-type="text">mst_id</th>
                                        <th onclick="sortTable('mstGrid', 2)" data-sort-type="number">ports</th>
                                        <th onclick="sortTable('mstGrid', 3)" data-sort-type="text">fda</th>
                                        <th onclick="sortTable('mstGrid', 4)" data-sort-type="text">fsa</th>
                                        <th onclick="sortTable('mstGrid', 5)" data-sort-type="text">spec</th>
                                        <th onclick="sortTable('mstGrid', 6)" data-sort-type="text">wkt_geom</th>
                                    </tr>
                                </thead>
                                <tbody id="mstGridBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- LGX Panel Input -->
                    <div class="input-section">
                        <div class="input-header">
                            <h2 class="input-title">🎛️ LGX Panel</h2>
                            <p class="input-subtitle">Port Assignments</p>
                        </div>
                        
                        <div class="grid-toolbar">
                            <div class="grid-actions">
                                <button class="grid-btn" onclick="clearLGXGrid()">
                                    <span>🗑️</span> Clear
                                </button>
                                <button class="grid-btn" onclick="addLGXRows(5)">
                                    <span>➕</span> Add Rows
                                </button>
                                <button class="grid-btn" onclick="importLGXFromExcel()">
                                    <span>📥</span> Import Excel
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid-wrapper">
                            <table class="data-grid" id="lgxGrid">
                                <thead>
                                    <tr>
                                        <th class="row-number-header">#</th>
                                        <th onclick="sortTable('lgxGrid', 1)" data-sort-type="number">fiber</th>
                                        <th onclick="sortTable('lgxGrid', 2)" data-sort-type="number">port</th>
                                        <th onclick="sortTable('lgxGrid', 3)" data-sort-type="text">mst_hub</th>
                                        <th onclick="sortTable('lgxGrid', 4)" data-sort-type="text">address</th>
                                        <th onclick="sortTable('lgxGrid', 5)" data-sort-type="text">customer_id</th>
                                    </tr>
                                </thead>
                                <tbody id="lgxGridBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- Process Section -->
                <div class="process-section">
                    <button class="process-btn" id="processBtn" onclick="processData()">
                        <span>⚡</span>
                        <span>Process Network Data</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Map Panel -->
        <div class="content-panel" id="map-panel">
            <div class="map-panel">
                <div id="networkMap"></div>
                
                <!-- Map Toolbar - Unified Command Center -->
                <div class="map-toolbar">
                    <!-- View Controls -->
                    <div class="toolbar-section">
                        <span class="toolbar-section-label">View</span>
                        <button class="map-tool active" id="selectTool" onclick="setMapTool('select')" title="Select and inspect network elements">
                            <span>👆</span> <span>Select</span>
                        </button>
                        <button class="map-tool icon-only" onclick="zoomToFit()" title="Fit network to view">
                            <span>⊡</span> <span>Fit View</span>
                        </button>
                        <button class="map-tool" id="hierarchyAll" onclick="setHierarchyView('all')" title="Show all network elements">
                            <span>🌐</span> <span>All</span>
                        </button>
                        <button class="map-tool" id="hierarchyFSA" onclick="setHierarchyView('fsa')" title="Show FSA level only">
                            <span>🏢</span> <span>FSA</span>
                        </button>
                        <button class="map-tool" id="hierarchyFDA" onclick="setHierarchyView('fda')" title="Show FDA level only">
                            <span>🏘️</span> <span>FDA</span>
                        </button>
                    </div>
                    
                    <!-- Analysis Tools -->
                    <div class="toolbar-section">
                        <span class="toolbar-section-label">Analyze</span>
                        <button class="map-tool" id="traceTool" onclick="setMapTool('trace')" title="Trace fiber path between points">
                            <span>🔍</span> <span>Trace Path</span>
                        </button>
                        <button class="map-tool" id="customerTraceTool" onclick="setMapTool('customerTrace')" title="Trace from customer to active cabinet">
                            <span>🏠</span> <span>Customer</span>
                        </button>
                        <button class="map-tool" id="measureTool" onclick="setMapTool('measure')" title="Measure distance">
                            <span>📏</span> <span>Measure</span>
                        </button>
                        <button class="map-tool icon-only" onclick="performManualSnap()" title="Snap cables to splice points">
                            <span>🧲</span> <span>Snap</span>
                        </button>
                    </div>
                    
                    <!-- Data Tools -->
                    <div class="toolbar-section">
                        <span class="toolbar-section-label">Data</span>
                        <button class="map-tool icon-only" onclick="showLGXPanel()" title="Show LGX panel assignments">
                            <span>🎛️</span> <span>LGX</span>
                        </button>
                        <button class="map-tool icon-only" onclick="validateNetwork()" title="Validate network integrity">
                            <span>✓</span> <span>Validate</span>
                        </button>
                        <button class="map-tool icon-only" onclick="exportKML()" title="Export network to KML">
                            <span>📥</span> <span>Export</span>
                        </button>
                        <button class="map-tool icon-only" onclick="refreshMap()" title="Refresh map view">
                            <span>🔄</span> <span>Refresh</span>
                        </button>
                    </div>
                </div>
                
                <!-- Customer Trace Panel -->
                <div class="customer-trace-panel" id="customerTracePanel">
                    <div class="customer-trace-input">
                        <input type="text" class="customer-input" id="customerAddressInput" 
                               placeholder="Enter customer address (e.g., 3611 SCENIC HWY)">
                        <button class="trace-btn" onclick="traceCustomerPath()">
                            Trace to Active Cabinet
                        </button>
                    </div>
                </div>
                
                <!-- Floating Panels -->
                <div class="floating-panel stats-panel fade-in">
                    <div class="panel-header">
                        <h3 class="panel-title">Network Overview</h3>
                        <button class="panel-close" onclick="togglePanel(this)">×</button>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="statCables">0</div>
                            <div class="stat-label">Cables</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statSplices">0</div>
                            <div class="stat-label">Splices</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statCabinets">0</div>
                            <div class="stat-label">Cabinets</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statMSTs">0</div>
                            <div class="stat-label">MSTs</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statCustomers">0</div>
                            <div class="stat-label">Addresses</div>
                        </div>
                    </div>
                    <div style="padding: 0 1.5rem 1.5rem; text-align: center;">
                        <div id="fsaInfo" style="font-size: 0.875rem; color: var(--text-light); margin-top: -0.5rem;">
                            <!-- FSA info will be populated here -->
                        </div>
                        <div id="lightSourceInfo" style="font-size: 0.875rem; color: var(--primary); margin-top: 0.5rem; font-weight: 600;">
                            <!-- Light source info will be populated here -->
                        </div>
                        <div id="snapInfo" style="font-size: 0.875rem; color: var(--success); margin-top: 0.5rem;">
                            <!-- Snap info will be populated here -->
                        </div>
                    </div>
                </div>
                
                <div class="floating-panel search-panel fade-in">
                    <div class="panel-header">
                        <h3 class="panel-title">Search Network</h3>
                        <button class="panel-close" onclick="togglePanel(this)">×</button>
                    </div>
                    <div class="search-input-wrapper">
                        <span class="search-icon">🔍</span>
                        <input type="text" class="search-input" placeholder="Search cables, splices, cabinets, MSTs, or addresses..." 
                               id="searchInput" oninput="performNetworkSearch()">
                    </div>
                    <div class="search-results" id="searchResults">
                    </div>
                </div>
                
                <div class="floating-panel legend-panel fade-in">
                    <h4 class="legend-title">Map Legend</h4>
                    <div class="legend-items">
                        <div class="legend-item">
                            <div class="legend-square" style="background: var(--error);"></div>
                            <span>Active Cabinet</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-square" style="background: var(--warning);"></div>
                            <span>Passive Cabinet</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-marker" style="background: var(--primary);"></div>
                            <span>Splice Point</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-marker" style="background: var(--info); width: 12px; height: 12px;"></div>
                            <span>MST Hub</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-marker" style="background: var(--success); width: 8px; height: 8px;"></div>
                            <span>Service Location</span>
                        </div>
                        <div class="legend-item" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                            <div class="legend-line" style="background: #3b82f6;"></div>
                            <span>FEEDER (T3)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #10b981;"></div>
                            <span>DISTRIBUTION (T2)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #f59e0b;"></div>
                            <span>MST TAIL (T1_TAIL)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-marker" style="background: var(--success); width: 12px; height: 12px; animation: pulse 2s infinite;"></div>
                            <span>Snapped Connection</span>
                        </div>
                    </div>
                </div>
                
                <!-- LGX Panel Display -->
                <div class="lgx-panel" id="lgxPanelDisplay">
                    <div class="lgx-panel-header">
                        <h3 class="panel-title" id="lgxPanelTitle">LGX Panel</h3>
                        <button class="panel-close" onclick="closeLGXPanel()">×</button>
                    </div>
                    <div class="lgx-panel-content">
                        <div class="lgx-port-grid" id="lgxPortGrid">
                            <!-- LGX ports will be dynamically generated -->
                        </div>
                    </div>
                </div>
                
                <!-- Path Trace Panel -->
                <div class="path-trace-panel" id="pathTracePanel">
                    <div class="path-trace-header">
                        <h3 class="panel-title">Fiber Path Trace</h3>
                        <button class="panel-close" onclick="closePathTracePanel()">×</button>
                    </div>
                    <div id="pathTraceContent">
                        <!-- Path trace details will be shown here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Splicing Documents Panel -->
        <div class="content-panel" id="splicing-panel">
            <div class="splicing-panel">
                <div class="splicing-container">
                    <div class="splice-doc-header">
                        <h2 style="font-size: 1.5rem; font-weight: 600; color: var(--secondary); margin-bottom: 0.5rem;">
                            Splice Documentation
                        </h2>
                        <p style="color: var(--text-light);">
                            Generated using GEM Fiber logic - Light source cable detection and automated splice mapping
                        </p>
                        
                        <div class="splice-doc-actions">
                            <button class="export-btn" onclick="exportSpliceExcel()">
                                <span>📊</span> Export Excel
                            </button>
                            <button class="export-btn" onclick="generatePDF()">
                                <span>📄</span> Generate PDF
                            </button>
                            <button class="export-btn" onclick="printSpliceSheets()">
                                <span>🖨️</span> Print Sheets
                            </button>
                        </div>
                    </div>
                    
                    <div id="spliceMatrixContainer">
                        <!-- Splice sheets will be generated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Analysis Panel -->
        <div class="content-panel" id="analysis-panel">
            <div class="data-input-panel">
                <h2 style="text-align: center; margin-bottom: 2rem; color: var(--secondary);">
                    Network Utilization Dashboard
                </h2>
                
                <div id="utilizationDashboard" style="display: none;">
                    <!-- FDA/FSA Summary Cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                        <div class="input-section" style="padding: 1.5rem;">
                            <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--secondary); margin-bottom: 1rem;">
                                Network Summary
                            </h3>
                            <div id="networkSummary" style="display: grid; gap: 0.75rem;">
                                <!-- Summary stats will be populated here -->
                            </div>
                        </div>
                        
                        <div class="input-section" style="padding: 1.5rem;">
                            <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--secondary); margin-bottom: 1rem;">
                                Fiber Utilization by Type
                            </h3>
                            <div id="fiberTypeUtilization" style="display: grid; gap: 0.75rem;">
                                <!-- Utilization by cable type will be shown here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- FDA Breakdown -->
                    <div class="input-section" style="padding: 1.5rem;">
                        <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--secondary); margin-bottom: 1rem;">
                            Utilization by FDA
                        </h3>
                        <div id="fdaUtilization" style="overflow-x: auto;">
                            <!-- FDA table will be populated here -->
                        </div>
                    </div>
                    
                    <!-- Cable Detail Table -->
                    <div class="input-section" style="padding: 1.5rem; margin-top: 1.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--secondary);">
                                Cable Utilization Details
                            </h3>
                            <button class="export-btn" onclick="exportNetworkData()">
                                <span>📊</span> Export All Data
                            </button>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label style="font-size: 0.875rem; color: var(--text-light);">Filter by FDA:</label>
                            <select id="fdaFilter" onchange="filterUtilizationTable()" style="margin-left: 0.5rem; padding: 0.375rem 0.75rem; border: 1px solid var(--border); border-radius: var(--radius-sm);">
                                <option value="">All FDAs</option>
                            </select>
                        </div>
                        <div id="cableUtilizationTable" style="overflow-x: auto;">
                            <!-- Cable detail table will be populated here -->
                        </div>
                    </div>
                </div>
                
                <div id="noDataMessage" style="text-align: center; margin: 4rem 0; color: var(--text-light);">
                    Process network data to view utilization dashboard
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification">
        <span class="notification-icon">✅</span>
        <div class="notification-content">
            <div class="notification-title" id="notificationTitle">Success!</div>
            <div class="notification-message" id="notificationMessage">Data imported successfully</div>
        </div>
    </div>
    
    <!-- Leaflet JS - Load before main script -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
        // Wait for Leaflet to load
        window.addEventListener('load', function() {
            console.log('Window loaded, checking for Leaflet...');
            if (typeof L === 'undefined') {
                console.error('Leaflet failed to load!');
                showNotification('Error', 'Map library failed to load. Please refresh the page.', 'error');
            } else {
                console.log('Leaflet loaded successfully');
            }
        });
        
        // =====================================================================
        // GLOBAL STATE - Enhanced with tier definitions
        // =====================================================================
        
        // Tier Definitions based on your specifications
        const TIER_DEFINITIONS = {
            'T1': { name: 'Fiber Drop', description: 'MST to Customer', color: '#ef4444' },
            'T1_TAIL': { name: 'MST Tail', description: 'Distribution to MST', color: '#f59e0b' },
            'T2': { name: 'Distribution', description: 'Passive Cabinet to MST', color: '#10b981' },
            'T3': { name: 'Feeder', description: 'Active to Passive Cabinet', color: '#3b82f6' },
            'T4': { name: 'County Link', description: 'Between Active Cabinets (County)', color: '#8b5cf6' },
            'T5': { name: 'Inter-County', description: 'Between Counties', color: '#6366f1' }
        };
        
        // History for undo/redo
        const HISTORY_STACK = [];
        let HISTORY_INDEX = -1;
        const MAX_HISTORY = 50;
        
        let cableData = [];
        let spliceData = [];
        let cabinetData = [];
        let mstData = [];
        let lgxData = [];
        let serviceLocationData = [];
        
        let map = null;
        let networkLayers = {
            cables: {},
            splices: {},
            cabinets: {},
            msts: {},
            serviceLocations: {},
            labels: {},
            highlights: [],
            customerCluster: null,
            snapIndicators: [] // New layer for snap indicators
        };
        
        // GEM Fiber specific variables
        let lightSourceCable = null;
        let cableMap = {};
        let processedConnections = [];
        let deadFiberMap = {};
        let parsingErrors = [];
        
        // Map interaction state
        let currentMapTool = 'select';
        let currentHierarchyView = 'all';
        
        // Processed network data
        window.processedNetwork = null;
        
        // =====================================================================
        // GEOMETRY PARSING UTILITIES - Enhanced for MultiLineString
        // =====================================================================
        
        // Add MultiLineString parser
        function parseMultiLineString(wkt) {
            const coords = [];
            const match = wkt.match(/MULTILINESTRING\s*\(\s*\(\s*(.+)\s*\)\s*\)/);
            if (match) {
                // Extract the first LineString from MultiLineString
                // Split by '), (' to separate multiple linestrings if present
                const linestrings = match[1].split(/\)\s*,\s*\(/);
                
                // Parse the first linestring (main cable path)
                const firstLinestring = linestrings[0].replace(/[()]/g, '');
                const pairs = firstLinestring.split(',');
                
                pairs.forEach(pair => {
                    const [lng, lat] = pair.trim().split(' ').map(parseFloat);
                    if (!isNaN(lng) && !isNaN(lat)) {
                        coords.push([lat, lng]);
                    }
                });
            }
            return coords;
        }
        
        // Generic geometry parser
        function parseGeometry(wkt) {
            if (!wkt) return null;
            
            if (wkt.includes('MULTILINESTRING')) {
                return parseMultiLineString(wkt);
            } else if (wkt.includes('LINESTRING')) {
                return parseLineString(wkt);
            } else if (wkt.includes('POINT')) {
                return [parsePoint(wkt)];
            }
            return null;
        }
        
        // =====================================================================
        // SMART PASTE IMPLEMENTATION
        // =====================================================================
        
        const SmartPaste = {
            // Validation rules for each grid type
            validationRules: {
                cable: {
                    cable_type: { 
                        required: true, 
                        values: ['FEEDER', 'DISTRIBUTION', 'MST TAIL', 'TAIL', 'DROP'] 
                    },
                    fondid: { required: true, unique: true },
                    size: { required: true, type: 'number' },
                    cable_ct: { required: false },
                    wkt_geom: { required: false, type: 'geometry' }
                },
                splice: {
                    fondid: { required: true, unique: true },
                    fda: { required: false },
                    fsa: { required: false },
                    placement: { required: false },
                    spec: { required: false },
                    ap_type: { required: false },
                    wkt_geom: { required: false, type: 'geometry' }
                },
                cabinet: {
                    cabinet_id: { required: true, unique: true },
                    type: { required: false },
                    cab_size: { required: false, type: 'number' },
                    fsa: { required: false },
                    fda: { required: false },
                    spec: { required: false },
                    wkt_geom: { required: false, type: 'geometry' }
                },
                mst: {
                    mst_id: { required: true, unique: true },
                    ports: { required: false, type: 'number' },
                    fda: { required: false },
                    fsa: { required: false },
                    spec: { required: false },
                    wkt_geom: { required: false, type: 'geometry' }
                },
                lgx: {
                    fiber: { required: true, type: 'number' },
                    port: { required: true, type: 'number' },
                    mst_hub: { required: true },
                    address: { required: false },
                    customer_id: { required: false }
                }
            },

            // Parse pasted data
            parseClipboardData(data) {
                const lines = data.trim().split('\n');
                if (lines.length === 0) return null;
                
                // Detect delimiter
                const firstLine = lines[0];
                const delimiter = firstLine.includes('\t') ? '\t' : ',';
                
                // Parse headers
                const headers = firstLine.split(delimiter).map(h => h.trim());
                
                // Parse data rows
                const dataRows = lines.slice(1).filter(line => line.trim());
                
                return {
                    headers: headers,
                    dataRows: dataRows,
                    delimiter: delimiter,
                    isQGIS: headers.some(h => h.toLowerCase() === 'wkt_geom')
                };
            },

            // Auto-map columns based on header names
            autoMapColumns(headers, gridType) {
                const mapping = {};
                const gridFields = this.getGridFields(gridType);
                
                headers.forEach((header, index) => {
                    const cleanHeader = header.toLowerCase().replace(/[_\s]/g, '');
                    
                    // Direct matches
                    const directMatch = gridFields.find(field => 
                        field.toLowerCase().replace(/[_\s]/g, '') === cleanHeader
                    );
                    
                    if (directMatch) {
                        mapping[index] = directMatch;
                    } else {
                        // Fuzzy matching for common variations
                        const fuzzyMatches = {
                            'geometry': 'wkt_geom',
                            'geom': 'wkt_geom',
                            'wktgeom': 'wkt_geom',
                            'cabletype': 'cable_type',
                            'type': 'cable_type',
                            'cablect': 'cable_ct',
                            'count': 'cable_ct',
                            'fibers': 'size',
                            'fibercount': 'size',
                            'cabinetid': 'cabinet_id',
                            'cabsize': 'cab_size',
                            'mstid': 'mst_id',
                            'msthub': 'mst_hub',
                            'customerid': 'customer_id',
                            'aptype': 'ap_type'
                        };
                        
                        if (fuzzyMatches[cleanHeader]) {
                            mapping[index] = fuzzyMatches[cleanHeader];
                        }
                    }
                });
                
                return mapping;
            },

            // Get available fields for grid type
            getGridFields(gridType) {
                const fields = {
                    cable: ['cable_type', 'fondid', 'size', 'cable_ct', 'wkt_geom'],
                    splice: ['fondid', 'fda', 'fsa', 'placement', 'spec', 'ap_type', 'wkt_geom'],
                    cabinet: ['cabinet_id', 'type', 'cab_size', 'fsa', 'fda', 'spec', 'wkt_geom'],
                    mst: ['mst_id', 'ports', 'fda', 'fsa', 'spec', 'wkt_geom'],
                    lgx: ['fiber', 'port', 'mst_hub', 'address', 'customer_id']
                };
                return fields[gridType] || [];
            },

            // Show preview dialog
            showPreviewDialog(parsedData, mapping, gridType) {
                const dialog = document.createElement('div');
                dialog.className = 'smart-paste-dialog';
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                // Check for existing data that will be replaced
                const existingData = collectGridData(gridType);
                const hasExistingData = existingData.length > 0;
                
                dialog.innerHTML = `
                    <div class="dialog-overlay" onclick="SmartPaste.cancelPaste()" 
                         style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; 
                                background: rgba(0,0,0,0.5);"></div>
                    <div class="dialog-content" style="
                        position: relative;
                        background: white;
                        border-radius: 12px;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
                        max-width: 800px;
                        max-height: 80vh;
                        overflow: hidden;
                        display: flex;
                        flex-direction: column;
                    ">
                        <div class="dialog-header" style="
                            padding: 1.5rem;
                            border-bottom: 1px solid #e2e8f0;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        ">
                            <h3 style="margin: 0; font-size: 1.25rem; font-weight: 600; color: #1e293b;">
                                Smart Paste Preview - ${gridType.charAt(0).toUpperCase() + gridType.slice(1)} Data
                            </h3>
                            <button onclick="SmartPaste.cancelPaste()" style="
                                background: none;
                                border: none;
                                font-size: 1.5rem;
                                cursor: pointer;
                                color: #64748b;
                                padding: 0;
                                width: 32px;
                                height: 32px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                border-radius: 6px;
                                transition: all 0.2s;
                            " onmouseover="this.style.background='#f1f5f9'" 
                               onmouseout="this.style.background='none'">×</button>
                        </div>
                        
                        <div class="dialog-body" style="
                            flex: 1;
                            overflow-y: auto;
                            padding: 1.5rem;
                        ">
                            ${hasExistingData ? `
                                <div style="
                                    background: #fef3c7;
                                    border: 1px solid #fbbf24;
                                    border-radius: 8px;
                                    padding: 1rem;
                                    margin-bottom: 1rem;
                                    display: flex;
                                    align-items: center;
                                    gap: 0.75rem;
                                ">
                                    <span style="font-size: 1.25rem;">⚠️</span>
                                    <div>
                                        <strong>Warning:</strong> This will replace ${existingData.length} existing rows in the ${gridType} grid.
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div style="margin-bottom: 1.5rem;">
                                <h4 style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: #334155;">
                                    Column Mapping
                                </h4>
                                <div style="
                                    background: #f8fafc;
                                    border: 1px solid #e2e8f0;
                                    border-radius: 8px;
                                    padding: 1rem;
                                ">
                                    <p style="margin: 0 0 1rem 0; font-size: 0.875rem; color: #64748b;">
                                        ${parsedData.isQGIS ? '📍 QGIS data detected.' : '📋 Spreadsheet data detected.'} 
                                        Found ${parsedData.dataRows.length} rows with ${parsedData.headers.length} columns.
                                    </p>
                                    ${this.generateMappingTable(parsedData, mapping, gridType)}
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <h4 style="font-size: 1rem; font-weight: 600; margin-bottom: 0.5rem; color: #334155;">
                                    Data Preview
                                </h4>
                                ${this.generatePreviewTable(parsedData, mapping, 3)}
                            </div>
                        </div>
                        
                        <div class="dialog-footer" style="
                            padding: 1.5rem;
                            border-top: 1px solid #e2e8f0;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        ">
                            <div style="font-size: 0.875rem; color: #64748b;">
                                Ready to import ${parsedData.dataRows.length} rows
                            </div>
                            <div style="display: flex; gap: 0.75rem;">
                                <button onclick="SmartPaste.cancelPaste()" style="
                                    padding: 0.5rem 1.5rem;
                                    background: white;
                                    border: 1px solid #e2e8f0;
                                    border-radius: 6px;
                                    font-weight: 500;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                ">Cancel</button>
                                <button onclick="SmartPaste.confirmPaste('${gridType}')" style="
                                    padding: 0.5rem 1.5rem;
                                    background: #FF6B35;
                                    color: white;
                                    border: none;
                                    border-radius: 6px;
                                    font-weight: 500;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                ">Import Data</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
                // Store current paste data
                this.pendingPaste = {
                    parsedData: parsedData,
                    mapping: mapping
                };
            },

            // Generate mapping table
            generateMappingTable(parsedData, mapping, gridType) {
                const fields = this.getGridFields(gridType);
                const unmappedFields = fields.filter(field => 
                    !Object.values(mapping).includes(field)
                );
                
                let html = '<table style="width: 100%; font-size: 0.875rem;">';
                html += '<thead><tr>';
                html += '<th style="padding: 0.5rem; text-align: left;">Source Column</th>';
                html += '<th style="padding: 0.5rem; text-align: left;">→</th>';
                html += '<th style="padding: 0.5rem; text-align: left;">Target Field</th>';
                html += '</tr></thead><tbody>';
                
                parsedData.headers.forEach((header, index) => {
                    const isGeometry = header.toLowerCase().includes('geom') || 
                                      header.toLowerCase() === 'geometry';
                    
                    html += '<tr>';
                    html += `<td style="padding: 0.5rem;">${header}</td>`;
                    html += '<td style="padding: 0.5rem; text-align: center;">→</td>';
                    html += '<td style="padding: 0.5rem;">';
                    html += `<select id="mapping_${index}" onchange="SmartPaste.updateMapping(${index}, this.value)" 
                              style="width: 100%; padding: 0.25rem; border: 1px solid #e2e8f0; border-radius: 4px;">`;
                    html += '<option value="">-- Skip --</option>';
                    
                    fields.forEach(field => {
                        const selected = mapping[index] === field ? 'selected' : '';
                        html += `<option value="${field}" ${selected}>${field}</option>`;
                    });
                    
                    html += '</select></td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                
                if (unmappedFields.length > 0) {
                    html += `<p style="margin-top: 0.5rem; font-size: 0.75rem; color: #f59e0b;">
                             ⚠️ Unmapped fields: ${unmappedFields.join(', ')}</p>`;
                }
                
                return html;
            },

            // Generate preview table
            generatePreviewTable(parsedData, mapping, rowCount = 3) {
                const mappedHeaders = parsedData.headers.filter((_, index) => mapping[index]);
                const previewRows = parsedData.dataRows.slice(0, rowCount);
                
                let html = '<div style="overflow-x: auto;">';
                html += '<table style="width: 100%; font-size: 0.8125rem; border-collapse: collapse;">';
                html += '<thead><tr>';
                
                parsedData.headers.forEach((header, index) => {
                    if (mapping[index]) {
                        html += `<th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #e2e8f0; 
                                 font-weight: 600; color: #334155;">
                                 ${mapping[index]}<br>
                                 <span style="font-weight: 400; font-size: 0.75rem; color: #64748b;">${header}</span>
                                 </th>`;
                    }
                });
                
                html += '</tr></thead><tbody>';
                
                previewRows.forEach((row, rowIndex) => {
                    const cells = row.split(parsedData.delimiter);
                    html += '<tr>';
                    
                    cells.forEach((cell, cellIndex) => {
                        if (mapping[cellIndex]) {
                            const value = cell.trim();
                            let displayValue = value;
                            
                            // Special formatting for geometry
                            if (mapping[cellIndex] === 'wkt_geom' && value.length > 50) {
                                const geomType = value.match(/^[A-Z]+/)?.[0] || 'GEOMETRY';
                                displayValue = `<span style="color: #3b82f6;">${geomType}</span> 
                                               <span style="color: #64748b;">(${value.length} chars)</span>`;
                            }
                            
                            html += `<td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">
                                     ${displayValue}
                                     </td>`;
                        }
                    });
                    
                    html += '</tr>';
                });
                
                if (parsedData.dataRows.length > rowCount) {
                    html += `<tr><td colspan="${Object.keys(mapping).length}" 
                             style="padding: 0.5rem; text-align: center; color: #64748b; 
                             font-style: italic; border-bottom: 1px solid #f1f5f9;">
                             ... and ${parsedData.dataRows.length - rowCount} more rows
                             </td></tr>`;
                }
                
                html += '</tbody></table></div>';
                return html;
            },

            // Update mapping
            updateMapping(index, value) {
                if (this.pendingPaste) {
                    if (value) {
                        this.pendingPaste.mapping[index] = value;
                    } else {
                        delete this.pendingPaste.mapping[index];
                    }
                }
            },

            // Cancel paste
            cancelPaste() {
                const dialog = document.querySelector('.smart-paste-dialog');
                if (dialog) {
                    dialog.remove();
                }
                this.pendingPaste = null;
            },

            // Confirm paste
            confirmPaste(gridType) {
                if (!this.pendingPaste) return;
                
                const { parsedData, mapping } = this.pendingPaste;
                
                // Clear existing data
                if (gridType === 'cable') clearCableGrid();
                else if (gridType === 'splice') clearSpliceGrid();
                else if (gridType === 'cabinet') clearCabinetGrid();
                else if (gridType === 'mst') clearMSTGrid();
                else if (gridType === 'lgx') clearLGXGrid();
                
                // Track updates vs inserts
                const existingFondids = new Map();
                const currentData = collectGridData(gridType);
                currentData.forEach((item, index) => {
                    if (item.fondid) {
                        existingFondids.set(item.fondid, index);
                    }
                });
                
                let insertCount = 0;
                let updateCount = 0;
                
                // Import data
                parsedData.dataRows.forEach((row, rowIndex) => {
                    const cells = row.split(parsedData.delimiter);
                    
                    // Check if this is an update (fondid exists)
                    let fondidValue = null;
                    const fondidIndex = Object.entries(mapping).find(([_, field]) => field === 'fondid')?.[0];
                    if (fondidIndex !== undefined) {
                        fondidValue = cells[fondidIndex]?.trim();
                    }
                    
                    if (fondidValue && existingFondids.has(fondidValue)) {
                        updateCount++;
                    } else {
                        insertCount++;
                    }
                    
                    // Add row
                    if (gridType === 'cable') addCableRows(1);
                    else if (gridType === 'splice') addSpliceRows(1);
                    else if (gridType === 'cabinet') addCabinetRows(1);
                    else if (gridType === 'mst') addMSTRows(1);
                    else if (gridType === 'lgx') addLGXRows(1);
                    
                    // Get the row element
                    const tbody = document.getElementById(`${gridType}GridBody`);
                    const rowElement = tbody.children[rowIndex];
                    
                    // Fill data
                    Object.entries(mapping).forEach(([sourceIndex, targetField]) => {
                        const input = rowElement.querySelector(`[data-field="${targetField}"]`);
                        if (input && cells[sourceIndex] !== undefined) {
                            let value = cells[sourceIndex].trim();
                            
                            // Handle MultiLineString conversion for display
                            if (targetField === 'wkt_geom' && value.includes('MULTILINESTRING')) {
                                // Store as-is but mark for special handling
                                input.dataset.geometryType = 'MULTILINESTRING';
                            }
                            
                            input.value = value;
                            input.dispatchEvent(new Event('input'));
                        }
                    });
                });
                
                // Close dialog
                this.cancelPaste();
                
                // Show success notification
                let message = `Successfully imported ${insertCount} new rows`;
                if (updateCount > 0) {
                    message += ` and updated ${updateCount} existing rows`;
                }
                message += ` into ${gridType} grid`;
                
                showNotification('Smart Paste Complete', message, 'success');
                
                // Update row counts
                if (gridType === 'cable') updateCableRowCount();
                else if (gridType === 'splice') updateSpliceRowCount();
                
                // Detect geo data
                if (gridType === 'cable' || gridType === 'splice') {
                    detectGeoData(gridType);
                }
                
                // Save state for undo
                saveHistoryState();
            },

            // Initiate paste process
            initiatePaste(pastedData, gridType) {
                const parsedData = this.parseClipboardData(pastedData);
                if (!parsedData || parsedData.dataRows.length === 0) {
                    showNotification('Paste Error', 'No valid data found in clipboard', 'error');
                    return;
                }
                
                // Auto-map columns
                const mapping = this.autoMapColumns(parsedData.headers, gridType);
                
                // Show preview dialog
                this.showPreviewDialog(parsedData, mapping, gridType);
            }
        };
        
        // =====================================================================
        // CABLE-TO-SPLICE SNAPPING SYSTEM - The Magic Begins Here! 🧲
        // =====================================================================
        
        // Global registry to track cable-splice connections
        const spliceConnections = {
            // Format: { spliceId: { cables: [], autoGenerated: boolean } }
        };
        
        // Configuration for snapping behavior
        const SNAP_CONFIG = {
            threshold: 0.0005, // ~50 meters in decimal degrees
            visualFeedback: true,
            autoGenerateSplice: true
        };
        
        // =====================================================================
        // CORE SNAPPING FUNCTIONS
        // =====================================================================
        
        /**
         * Extract endpoints from a LINESTRING WKT
         * Returns array of [startPoint, endPoint] where each point is [lat, lng]
         */
        function extractCableEndpoints(wktLinestring) {
            const coords = parseGeometry(wktLinestring);
            if (!coords || coords.length < 2) return null;
            
            return {
                start: coords[0],
                end: coords[coords.length - 1],
                allPoints: coords
            };
        }
        
        /**
         * Calculate distance between two points using Haversine formula
         * Returns distance in decimal degrees (approximate)
         */
        function calculateDistance(point1, point2) {
            const [lat1, lng1] = point1;
            const [lat2, lng2] = point2;
            
            // Simple Euclidean distance for small areas
            const dLat = lat2 - lat1;
            const dLng = lng2 - lng1;
            return Math.sqrt(dLat * dLat + dLng * dLng);
        }
        
        /**
         * Find the nearest splice point to a given location
         */
        function findNearestSplice(point, splices, threshold = SNAP_CONFIG.threshold) {
            let nearestSplice = null;
            let minDistance = Infinity;
            
            splices.forEach(splice => {
                if (!splice.wkt_geom || !splice.wkt_geom.includes('POINT')) return;
                
                const spliceCoords = parsePoint(splice.wkt_geom);
                if (!spliceCoords) return;
                
                const distance = calculateDistance(point, spliceCoords);
                
                if (distance < minDistance && distance <= threshold) {
                    minDistance = distance;
                    nearestSplice = {
                        splice: splice,
                        coords: spliceCoords,
                        distance: distance
                    };
                }
            });
            
            return nearestSplice;
        }
        
        /**
         * Snap a cable to nearby splice points and create connections
         */
        function snapCableToSplices(cable, splices) {
            if (!cable.wkt_geom) return null;
            
            const endpoints = extractCableEndpoints(cable.wkt_geom);
            if (!endpoints) return null;
            
            const connections = {
                start: null,
                end: null,
                modified: false
            };
            
            // Check start point
            const startSplice = findNearestSplice(endpoints.start, splices);
            if (startSplice) {
                connections.start = startSplice;
                console.log(`📍 Snapping ${cable.fondid} START to ${startSplice.splice.fondid}`);
            }
            
            // Check end point
            const endSplice = findNearestSplice(endpoints.end, splices);
            if (endSplice) {
                connections.end = endSplice;
                console.log(`📍 Snapping ${cable.fondid} END to ${endSplice.splice.fondid}`);
            }
            
            // If we found connections, update the cable geometry
            if (connections.start || connections.end) {
                connections.modified = true;
                connections.snappedGeometry = createSnappedGeometry(
                    endpoints.allPoints,
                    connections.start?.coords,
                    connections.end?.coords
                );
                
                // Register the connections
                registerSpliceConnection(cable, connections);
            }
            
            return connections;
        }
        
        /**
         * Create modified geometry with snapped endpoints
         */
        function createSnappedGeometry(originalPoints, snapStart, snapEnd) {
            const points = [...originalPoints];
            
            // Replace first point if snapping to start splice
            if (snapStart) {
                points[0] = snapStart;
            }
            
            // Replace last point if snapping to end splice
            if (snapEnd) {
                points[points.length - 1] = snapEnd;
            }
            
            return points;
        }
        
        /**
         * Register a cable-splice connection in our tracking system
         */
        function registerSpliceConnection(cable, connections) {
            // Register start splice connection
            if (connections.start) {
                const spliceId = connections.start.splice.fondid;
                if (!spliceConnections[spliceId]) {
                    spliceConnections[spliceId] = {
                        splice: connections.start.splice,
                        cables: [],
                        autoGenerated: false
                    };
                }
                spliceConnections[spliceId].cables.push({
                    cableId: cable.fondid,
                    cableType: cable.cable_type,
                    endpoint: 'start',
                    cable: cable
                });
            }
            
            // Register end splice connection
            if (connections.end) {
                const spliceId = connections.end.splice.fondid;
                if (!spliceConnections[spliceId]) {
                    spliceConnections[spliceId] = {
                        splice: connections.end.splice,
                        cables: [],
                        autoGenerated: false
                    };
                }
                spliceConnections[spliceId].cables.push({
                    cableId: cable.fondid,
                    cableType: cable.cable_type,
                    endpoint: 'end',
                    cable: cable
                });
            }
        }
        
        /**
         * Process all cables and snap them to nearby splices
         */
        function snapAllCables() {
            const network = window.processedNetwork;
            if (!network || !network.cables || !network.splices) {
                console.error('No network data available for snapping');
                return;
            }
            
            console.log('🧲 Starting cable-to-splice snapping process...');
            
            // Clear existing connections
            Object.keys(spliceConnections).forEach(key => delete spliceConnections[key]);
            
            let snappedCount = 0;
            const snapResults = [];
            
            // Process each cable
            network.cables.forEach(cable => {
                const result = snapCableToSplices(cable, network.splices);
                if (result && result.modified) {
                    snappedCount++;
                    snapResults.push({
                        cable: cable,
                        connections: result
                    });
                    
                    // Update the cable's internal geometry for rendering
                    cable._snappedGeometry = result.snappedGeometry;
                }
            });
            
            console.log(`✅ Snapped ${snappedCount} cables to splice points`);
            
            // Update snap info in stats panel
            document.getElementById('snapInfo').textContent = 
                `🧲 ${snappedCount} cables snapped to splices`;
            
            // Auto-generate splice cases for connected splices
            if (SNAP_CONFIG.autoGenerateSplice) {
                generateSpliceCasesFromConnections();
            }
            
            // Refresh the map to show snapped connections
            if (map && typeof renderNetworkOnMap === 'function') {
                updateMapWithSnappedCables(snapResults);
            }
            
            return snapResults;
        }
        
        /**
         * Update map rendering with snapped cables
         */
        function updateMapWithSnappedCables(snapResults) {
            // Clear old snap indicators
            networkLayers.snapIndicators.forEach(layer => map.removeLayer(layer));
            networkLayers.snapIndicators = [];
            
            snapResults.forEach(({cable, connections}) => {
                const layer = networkLayers.cables[cable.fondid];
                if (layer && connections.snappedGeometry) {
                    // Update the polyline with snapped geometry
                    layer.setLatLngs(connections.snappedGeometry);
                    
                    // Add visual indicators for snapped endpoints
                    if (SNAP_CONFIG.visualFeedback) {
                        // Add green circles at snapped points
                        if (connections.start) {
                            const startMarker = L.circleMarker(connections.start.coords, {
                                radius: 6,
                                fillColor: '#10b981',
                                color: 'white',
                                weight: 2,
                                fillOpacity: 0.8,
                                className: 'snap-indicator'
                            }).addTo(map);
                            startMarker.bindPopup(`✅ ${cable.fondid} snapped to ${connections.start.splice.fondid}`);
                            networkLayers.snapIndicators.push(startMarker);
                        }
                        
                        if (connections.end) {
                            const endMarker = L.circleMarker(connections.end.coords, {
                                radius: 6,
                                fillColor: '#10b981',
                                color: 'white',
                                weight: 2,
                                fillOpacity: 0.8,
                                className: 'snap-indicator'
                            }).addTo(map);
                            endMarker.bindPopup(`✅ ${cable.fondid} snapped to ${connections.end.splice.fondid}`);
                            networkLayers.snapIndicators.push(endMarker);
                        }
                    }
                }
            });
        }
        
        /**
         * Auto-generate splice cases from snapped connections
         */
        function generateSpliceCasesFromConnections() {
            console.log('📋 Generating splice cases from connections...');
            
            Object.keys(spliceConnections).forEach(spliceId => {
                const spliceData = spliceConnections[spliceId];
                
                // Only generate if we have 2+ cables at this splice
                if (spliceData.cables.length >= 2) {
                    console.log(`Creating splice case for ${spliceId} with ${spliceData.cables.length} cables`);
                    
                    // Identify cable pairs for splicing
                    const cablePairs = identifyCablePairs(spliceData.cables);
                    
                    // Generate splice matrix for each pair
                    cablePairs.forEach(pair => {
                        generateSpliceMatrix(spliceId, pair);
                    });
                    
                    spliceData.autoGenerated = true;
                }
            });
        }
        
        /**
         * Identify which cables should be spliced together at a splice point
         */
        function identifyCablePairs(cables) {
            const pairs = [];
            
            // Sort cables by type priority (FEEDER > DISTRIBUTION > TAIL)
            const typePriority = { 'FEEDER': 3, 'DISTRIBUTION': 2, 'MST TAIL': 1 };
            cables.sort((a, b) => (typePriority[b.cableType] || 0) - (typePriority[a.cableType] || 0));
            
            // Simple pairing: connect higher tier to lower tier
            for (let i = 0; i < cables.length - 1; i++) {
                pairs.push({
                    cableIn: cables[i],
                    cableOut: cables[i + 1]
                });
            }
            
            return pairs;
        }
        
        /**
         * Generate splice matrix using existing GEM fiber logic
         */
        function generateSpliceMatrix(spliceId, cablePair) {
            const { cableIn, cableOut } = cablePair;
            
            // Use existing GEM fiber parser
            const cableInParsed = parseCableCt(cableIn.cable.cable_ct, cableIn.cableId);
            const cableOutParsed = parseCableCt(cableOut.cable.cable_ct, cableOut.cableId);
            
            // Generate connections based on parsed data
            // This integrates with your existing processActiveConnections logic
            console.log(`Splice matrix generated for ${spliceId}:`, {
                in: cableIn.cableId,
                out: cableOut.cableId,
                connections: Math.min(cableInParsed.totalLitFibers, cableOutParsed.totalLitFibers)
            });
        }
        
        /**
         * Find cables connected at a specific splice point
         */
        function findConnectedCables(spliceId) {
            return spliceConnections[spliceId]?.cables || [];
        }
        
        /**
         * Validate splice connections
         */
        function validateSpliceConnections() {
            const issues = [];
            
            Object.keys(spliceConnections).forEach(spliceId => {
                const data = spliceConnections[spliceId];
                
                // Check for single-cable splices (dead ends)
                if (data.cables.length === 1) {
                    issues.push({
                        type: 'warning',
                        spliceId: spliceId,
                        message: `Splice ${spliceId} has only one cable connected`
                    });
                }
                
                // Check for fiber count mismatches
                if (data.cables.length >= 2) {
                    const fiberCounts = data.cables.map(c => 
                        parseInt(c.cable.size) || 0
                    );
                    if (Math.max(...fiberCounts) > Math.min(...fiberCounts) * 2) {
                        issues.push({
                            type: 'warning',
                            spliceId: spliceId,
                            message: `Large fiber count mismatch at ${spliceId}`
                        });
                    }
                }
            });
            
            return issues;
        }
        
        /**
         * Enhanced findConnectedSplices function to use snap registry
         */
        function findConnectedSplices(cableId) {
            const connectedSplices = [];
            
            Object.keys(spliceConnections).forEach(spliceId => {
                const data = spliceConnections[spliceId];
                const hasCable = data.cables.some(c => c.cableId === cableId);
                if (hasCable) {
                    connectedSplices.push(spliceId);
                }
            });
            
            return connectedSplices;
        }
        
        // Export functions for use in main application
        window.cableSnapping = {
            snapAllCables,
            findConnectedCables,
            validateSpliceConnections,
            spliceConnections,
            config: SNAP_CONFIG
        };
        
        // =====================================================================
        // INITIALIZATION - Fix the loading issue
        // =====================================================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Initializing Phoenix Fiber');
            
            // Wait for all scripts to load
            if (document.readyState === 'complete') {
                initializeApp();
            } else {
                window.addEventListener('load', initializeApp);
            }
        });
        
        // Check if all required libraries are loaded
        function checkLibraries() {
            const required = {
                'Leaflet': typeof L !== 'undefined',
                'SheetJS': typeof XLSX !== 'undefined'
            };
            
            let allLoaded = true;
            for (let lib in required) {
                if (!required[lib]) {
                    console.error(`${lib} library not loaded!`);
                    allLoaded = false;
                }
            }
            
            return allLoaded;
        }
        
        // Initialize application when libraries are ready
        function initializeApp() {
            console.log('Initializing application...');
            
            if (!checkLibraries()) {
                console.error('Required libraries not loaded, retrying...');
                setTimeout(initializeApp, 500);
                return;
            }
            
            // Initialize tab switching
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Initialize keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // Initialize empty grids
            addCableRows(5);
            addSpliceRows(5);
            addCabinetRows(3);
            addMSTRows(3);
            addLGXRows(5);
            
            // Load sample data for testing
            setTimeout(() => {
                loadCableSample();
                loadSpliceSample();
            }, 100);
            
            console.log('Phoenix Fiber initialized successfully');
        }
        
        // =====================================================================
        // UI FUNCTIONS
        // =====================================================================
        function switchTab(tab) {
            console.log('Switching to tab:', tab);
            
            // Update tabs
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
            
            // Update panels
            document.querySelectorAll('.content-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(`${tab}-panel`).classList.add('active');
            
            // Initialize map if needed
            if (tab === 'map' && !map) {
                if (typeof L !== 'undefined') {
                    setTimeout(initializeMap, 100);
                } else {
                    console.error('Leaflet not loaded, cannot initialize map');
                    showNotification('Map Error', 'Map library not loaded. Please refresh the page.', 'error');
                }
            }
            
            // Generate splice documents if switching to splicing tab
            if (tab === 'splicing' && window.processedNetwork) {
                generateSpliceDocuments();
            }
            
            // Generate utilization dashboard if switching to analysis tab
            if (tab === 'analysis' && window.processedNetwork) {
                generateUtilizationDashboard();
            }
        }
        
        function showNotification(title, message, type = 'success') {
            const notification = document.getElementById('notification');
            const titleEl = document.getElementById('notificationTitle');
            const messageEl = document.getElementById('notificationMessage');
            const iconEl = notification.querySelector('.notification-icon');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Set icon and color based on type
            const icons = {
                success: '✅',
                error: '❌',
                info: 'ℹ️',
                warning: '⚠️'
            };
            
            const colors = {
                success: 'var(--success)',
                error: 'var(--error)',
                info: 'var(--info)',
                warning: 'var(--warning)'
            };
            
            notification.style.background = colors[type] || colors.success;
            iconEl.textContent = icons[type] || icons.success;
            
            // Show notification
            notification.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        function togglePanel(btn) {
            const panel = btn.closest('.floating-panel');
            // Store panel state
            if (panel.dataset.hidden === 'true') {
                panel.style.display = '';
                panel.dataset.hidden = 'false';
            } else {
                panel.style.display = 'none';
                panel.dataset.hidden = 'true';
            }
        }
        
        // =====================================================================
        // DATA GRID FUNCTIONS
        // =====================================================================
        
        // Track sort state for each table
        const sortState = {
            cableGrid: { column: -1, ascending: true },
            spliceGrid: { column: -1, ascending: true },
            cabinetGrid: { column: -1, ascending: true },
            mstGrid: { column: -1, ascending: true },
            lgxGrid: { column: -1, ascending: true }
        };
        
        /**
         * Intelligent table sorting function
         * Handles different data types and maintains visual feedback
         */
        function sortTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const headers = table.querySelectorAll('thead th');
            
            // Get the clicked header
            const clickedHeader = headers[columnIndex];
            const sortType = clickedHeader.getAttribute('data-sort-type') || 'text';
            
            // Determine sort direction
            const state = sortState[tableId];
            let ascending = true;
            
            if (state.column === columnIndex) {
                // Same column clicked - toggle direction
                ascending = !state.ascending;
            } else {
                // New column - default to ascending
                ascending = true;
            }
            
            // Update sort state
            state.column = columnIndex;
            state.ascending = ascending;
            
            // Clear all header classes
            headers.forEach(h => {
                h.classList.remove('sorting-asc', 'sorting-desc');
            });
            
            // Add appropriate class to clicked header
            clickedHeader.classList.add(ascending ? 'sorting-asc' : 'sorting-desc');
            
            // Extract data with row references
            const dataRows = rows.map(row => {
                const input = row.querySelectorAll('.grid-input')[columnIndex - 1]; // -1 because of row number column
                const value = input ? input.value.trim() : '';
                return { row, value, sortValue: getSortValue(value, sortType) };
            });
            
            // Sort the data
            dataRows.sort((a, b) => {
                let comparison = 0;
                
                // Handle empty values - always put them at the end
                if (a.value === '' && b.value === '') return 0;
                if (a.value === '') return 1;
                if (b.value === '') return -1;
                
                // Compare based on sort type
                if (sortType === 'number') {
                    comparison = a.sortValue - b.sortValue;
                } else {
                    // Text comparison
                    comparison = a.sortValue.localeCompare(b.sortValue);
                }
                
                return ascending ? comparison : -comparison;
            });
            
            // Reorder the table
            dataRows.forEach((item, index) => {
                tbody.appendChild(item.row);
                // Update row number
                const rowNumCell = item.row.querySelector('.row-number');
                if (rowNumCell) {
                    rowNumCell.textContent = index + 1;
                }
            });
            
            // Show notification
            const columnName = clickedHeader.textContent.replace(/[↑↓]/g, '').trim();
            showNotification('Table Sorted', 
                `Sorted by ${columnName} (${ascending ? 'A→Z' : 'Z→A'})`, 
                'info');
        }
        
        /**
         * Get sortable value based on data type
         */
        function getSortValue(value, sortType) {
            if (!value) return sortType === 'number' ? 0 : '';
            
            if (sortType === 'number') {
                // Extract numbers for sorting
                const num = parseFloat(value);
                return isNaN(num) ? 0 : num;
            } else if (value.includes('VAAUGS')) {
                // Special handling for FDA codes - extract numeric part
                const match = value.match(/\d+$/);
                return match ? value.replace(/\d+$/, match[0].padStart(4, '0')) : value.toUpperCase();
            } else if (value.includes('-F-') || value.includes('-D-') || value.includes('-T-')) {
                // Special handling for cable IDs - sort by type then number
                const parts = value.split('-');
                if (parts.length >= 3) {
                    const typeOrder = { 'F': '1', 'D': '2', 'T': '3' };
                    const type = typeOrder[parts[1]] || parts[1];
                    const num = parts[2] ? parts[2].padStart(4, '0') : '0000';
                    return `${parts[0]}-${type}-${num}`;
                }
                return value.toUpperCase();
            } else {
                // Regular text sorting
                return value.toUpperCase();
            }
        }
        
        /**
         * Smart column filter function
         */
        function filterTableColumn(tableId, columnIndex, filterValue) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const input = row.querySelectorAll('.grid-input')[columnIndex - 1];
                const value = input ? input.value.trim().toLowerCase() : '';
                const show = value.includes(filterValue.toLowerCase());
                
                row.style.display = show ? '' : 'none';
                if (show) visibleCount++;
            });
            
            return visibleCount;
        }
        
        /**
         * Quick filter by cable type
         */
        function quickFilterCableType(type) {
            const tbody = document.getElementById('cableGridBody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const typeInput = row.querySelector('[data-field="cable_type"]');
                const value = typeInput ? typeInput.value.trim() : '';
                
                if (type === 'ALL') {
                    row.style.display = '';
                } else {
                    row.style.display = value === type ? '' : 'none';
                }
            });
            
            // Update visible row numbers
            updateVisibleRowNumbers('cableGridBody');
            
            // Update row count
            const visibleRows = tbody.querySelectorAll('tr:not([style*="display: none"])').length;
            const totalRows = tbody.querySelectorAll('tr').length;
            document.getElementById('cableRowCount').textContent = 
                type === 'ALL' ? `${totalRows} rows` : `${visibleRows} of ${totalRows} rows (${type})`;
        }
        
        /**
         * Filter splices by FDA
         */
        function filterSplicesByFDA() {
            const filterValue = document.getElementById('spliceFdaFilter').value;
            const tbody = document.getElementById('spliceGridBody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const fdaInput = row.querySelector('[data-field="fda"]');
                const value = fdaInput ? fdaInput.value.trim() : '';
                
                if (filterValue === '') {
                    row.style.display = '';
                } else {
                    row.style.display = value === filterValue ? '' : 'none';
                }
            });
            
            // Update visible row numbers
            updateVisibleRowNumbers('spliceGridBody');
            
            // Update row count
            const visibleRows = tbody.querySelectorAll('tr:not([style*="display: none"])').length;
            const totalRows = tbody.querySelectorAll('tr').length;
            document.getElementById('spliceRowCount').textContent = 
                filterValue === '' ? `${totalRows} rows` : `${visibleRows} of ${totalRows} rows (${filterValue})`;
            
            // Dynamically update FDA options based on data
            updateFDAFilterOptions();
        }
        
        /**
         * Dynamically update FDA filter options based on actual data
         */
        function updateFDAFilterOptions() {
            const fdaSet = new Set();
            const tbody = document.getElementById('spliceGridBody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const fdaInput = row.querySelector('[data-field="fda"]');
                const value = fdaInput ? fdaInput.value.trim() : '';
                if (value) fdaSet.add(value);
            });
            
            const filter = document.getElementById('spliceFdaFilter');
            const currentValue = filter.value;
            
            // Clear existing options except "All FDAs"
            filter.innerHTML = '<option value="">All FDAs</option>';
            
            // Add options for each unique FDA
            Array.from(fdaSet).sort().forEach(fda => {
                const option = document.createElement('option');
                option.value = fda;
                option.textContent = fda;
                filter.appendChild(option);
            });
            
            // Restore previous selection if it still exists
            filter.value = currentValue;
        }
        
        /**
         * Update row numbers for visible rows only
         */
        function updateVisibleRowNumbers(tbodyId) {
            const tbody = document.getElementById(tbodyId);
            const rows = tbody.querySelectorAll('tr');
            let visibleIndex = 1;
            
            rows.forEach(row => {
                if (row.style.display !== 'none') {
                    const rowNumCell = row.querySelector('.row-number');
                    if (rowNumCell) {
                        rowNumCell.textContent = visibleIndex++;
                    }
                }
            });
        }
        
        function addCableRows(count) {
            const tbody = document.getElementById('cableGridBody');
            const currentRows = tbody.children.length;
            
            for (let i = 0; i < count; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="row-number">${currentRows + i + 1}</td>
                    <td><input type="text" class="grid-input" data-field="cable_type" oninput="validateCableInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="fondid" oninput="validateCableInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="size" oninput="validateCableInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="cable_ct" oninput="validateCableInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="wkt_geom" oninput="detectGeoData('cable', this)"></td>
                `;
            }
            updateCableRowCount();
        }
        
        function addSpliceRows(count) {
            const tbody = document.getElementById('spliceGridBody');
            const currentRows = tbody.children.length;
            
            for (let i = 0; i < count; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="row-number">${currentRows + i + 1}</td>
                    <td><input type="text" class="grid-input" data-field="fondid" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="fda" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="fsa" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="placement" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="spec" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="ap_type" oninput="validateSpliceInput(this)"></td>
                    <td><input type="text" class="grid-input" data-field="wkt_geom" oninput="detectGeoData('splice', this)"></td>
                `;
            }
            updateSpliceRowCount();
        }
        
        function addCabinetRows(count) {
            const tbody = document.getElementById('cabinetGridBody');
            const currentRows = tbody.children.length;
            
            for (let i = 0; i < count; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="row-number">${currentRows + i + 1}</td>
                    <td><input type="text" class="grid-input" data-field="cabinet_id"></td>
                    <td><input type="text" class="grid-input" data-field="type" placeholder="ACTIVE/PASSIVE"></td>
                    <td><input type="text" class="grid-input" data-field="cab_size" placeholder="288"></td>
                    <td><input type="text" class="grid-input" data-field="fsa"></td>
                    <td><input type="text" class="grid-input" data-field="fda"></td>
                    <td><input type="text" class="grid-input" data-field="spec"></td>
                    <td><input type="text" class="grid-input" data-field="wkt_geom"></td>
                `;
            }
        }
        
        function addMSTRows(count) {
            const tbody = document.getElementById('mstGridBody');
            const currentRows = tbody.children.length;
            
            for (let i = 0; i < count; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="row-number">${currentRows + i + 1}</td>
                    <td><input type="text" class="grid-input" data-field="mst_id"></td>
                    <td><input type="text" class="grid-input" data-field="ports" placeholder="4"></td>
                    <td><input type="text" class="grid-input" data-field="fda"></td>
                    <td><input type="text" class="grid-input" data-field="fsa"></td>
                    <td><input type="text" class="grid-input" data-field="spec" placeholder="Titan"></td>
                    <td><input type="text" class="grid-input" data-field="wkt_geom"></td>
                `;
            }
        }
        
        function addLGXRows(count) {
            const tbody = document.getElementById('lgxGridBody');
            const currentRows = tbody.children.length;
            
            for (let i = 0; i < count; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="row-number">${currentRows + i + 1}</td>
                    <td><input type="text" class="grid-input" data-field="fiber"></td>
                    <td><input type="text" class="grid-input" data-field="port"></td>
                    <td><input type="text" class="grid-input" data-field="mst_hub"></td>
                    <td><input type="text" class="grid-input" data-field="address"></td>
                    <td><input type="text" class="grid-input" data-field="customer_id"></td>
                `;
            }
        }
        
        function clearCableGrid() {
            document.getElementById('cableGridBody').innerHTML = '';
            updateCableRowCount();
            cableData = [];
        }
        
        function clearSpliceGrid() {
            document.getElementById('spliceGridBody').innerHTML = '';
            updateSpliceRowCount();
            spliceData = [];
        }
        
        function clearCabinetGrid() {
            document.getElementById('cabinetGridBody').innerHTML = '';
            cabinetData = [];
        }
        
        function clearMSTGrid() {
            document.getElementById('mstGridBody').innerHTML = '';
            mstData = [];
        }
        
        function clearLGXGrid() {
            document.getElementById('lgxGridBody').innerHTML = '';
            lgxData = [];
        }
        
        function updateCableRowCount() {
            const count = document.getElementById('cableGridBody').children.length;
            document.getElementById('cableRowCount').textContent = `${count} rows`;
        }
        
        function updateSpliceRowCount() {
            const count = document.getElementById('spliceGridBody').children.length;
            document.getElementById('spliceRowCount').textContent = `${count} rows`;
        }
        
        // Sample data loaders
        function loadCableSample() {
            clearCableGrid();
            const sampleData = [
                {cable_type: 'FEEDER', fondid: 'AUGS02-F-0001', size: '288', cable_ct: '1-288 AUGUSTA LGX 1-288 T3', wkt_geom: 'LINESTRING(-79.096154 38.314011, -79.095869 38.316235)'},
                {cable_type: 'DISTRIBUTION', fondid: 'AUGS02-D-0004', size: '144', cable_ct: '1-96 AUGS02-F-0001 1-96 T2; 97-144 XD', wkt_geom: 'LINESTRING(-79.095869 38.316235, -79.059368 38.336235)'},
                {cable_type: 'DISTRIBUTION', fondid: 'AUGS02-D-0207', size: '96', cable_ct: '1-48 IDEAA-AUGS-2_FDA_007 1-48 T2; 49-96 XD', wkt_geom: 'LINESTRING(-79.096135 38.314021, -79.058604 38.335795)'},
                {cable_type: 'MST TAIL', fondid: 'AUGS02-T-0012', size: '12', cable_ct: '1-4 AU02-T1_HUB_0012 1-4 T1_TAIL; 5-12 XD', wkt_geom: 'LINESTRING(-79.059368 38.336235, -79.057563 38.337445)'},
                {cable_type: 'MST TAIL', fondid: 'AUGS02-T-0013', size: '12', cable_ct: '1-8 AU02-T1_HUB_0013 1-8 T1_TAIL; 9-12 XD', wkt_geom: 'LINESTRING(-79.058604 38.335795, -79.056729 38.334745)'}
            ];
            
            // Load cabinets
            const cabinetSampleData = [
                {cabinet_id: 'FAC-AUGS-2', type: 'ACTIVE', cab_size: '288', fsa: 'VA-AUGS-02', fda: 'VAAUGS0207', spec: 'FAC-3200', wkt_geom: 'POINT(-79.09615407474086624 38.31401082417043114)'},
                {cabinet_id: 'IDEAA-AUGS-2_FDA_007', type: 'PASSIVE', cab_size: '288', fsa: 'VA-AUGS-02', fda: 'VAAUGS0207', spec: 'IDEAA', wkt_geom: 'POINT(-79.09613452730685879 38.31402142616851592)'}
            ];
            
            // Load MSTs (with 4 and 8 port examples)
            const mstSampleData = [
                {mst_id: 'AU02-T1_HUB_0012', ports: '4', fda: 'VAAUGS0204', fsa: 'VA-AUGS-02', spec: 'Titan', wkt_geom: 'POINT(-79.05936804768121817 38.33623457064457796)'},
                {mst_id: 'AU02-T1_HUB_0013', ports: '8', fda: 'VAAUGS0204', fsa: 'VA-AUGS-02', spec: 'Titan', wkt_geom: 'POINT(-79.05672940610585897 38.33474535003254147)'}
            ];
            
            // Load sample LGX data
            const lgxSampleData = [
                {fiber: '1', port: '1', mst_hub: 'AU02-T1_HUB_0012', address: '3611 SCENIC HWY', customer_id: 'CUST001'},
                {fiber: '2', port: '2', mst_hub: 'AU02-T1_HUB_0012', address: '3609 SCENIC HWY', customer_id: 'CUST002'},
                {fiber: '3', port: '3', mst_hub: 'AU02-T1_HUB_0012', address: '3595 SCENIC HWY', customer_id: ''},
                {fiber: '4', port: '4', mst_hub: 'AU02-T1_HUB_0012', address: '3764 SCENIC HWY', customer_id: 'CUST004'},
                {fiber: '5', port: '5', mst_hub: 'AU02-T1_HUB_0013', address: '3973 SCENIC HWY', customer_id: ''},
                {fiber: '6', port: '6', mst_hub: 'AU02-T1_HUB_0013', address: '3962 SCENIC HWY', customer_id: 'CUST006'},
                {fiber: '7', port: '7', mst_hub: 'AU02-T1_HUB_0013', address: '4100 SCENIC HWY', customer_id: ''},
                {fiber: '8', port: '8', mst_hub: 'AU02-T1_HUB_0013', address: '4186 SCENIC HWY', customer_id: ''}
            ];
            
            // Load cables
            sampleData.forEach((data, i) => {
                addCableRows(1);
                const row = document.getElementById('cableGridBody').children[i];
                row.querySelector('[data-field="cable_type"]').value = data.cable_type;
                row.querySelector('[data-field="fondid"]').value = data.fondid;
                row.querySelector('[data-field="size"]').value = data.size;
                row.querySelector('[data-field="cable_ct"]').value = data.cable_ct;
                row.querySelector('[data-field="wkt_geom"]').value = data.wkt_geom;
            });
            
            // Load cabinets
            clearCabinetGrid();
            cabinetSampleData.forEach((data, i) => {
                addCabinetRows(1);
                const row = document.getElementById('cabinetGridBody').children[i];
                row.querySelector('[data-field="cabinet_id"]').value = data.cabinet_id;
                row.querySelector('[data-field="type"]').value = data.type;
                row.querySelector('[data-field="cab_size"]').value = data.cab_size;
                row.querySelector('[data-field="fsa"]').value = data.fsa;
                row.querySelector('[data-field="fda"]').value = data.fda;
                row.querySelector('[data-field="spec"]').value = data.spec;
                row.querySelector('[data-field="wkt_geom"]').value = data.wkt_geom;
            });
            
            // Load MSTs
            clearMSTGrid();
            mstSampleData.forEach((data, i) => {
                addMSTRows(1);
                const row = document.getElementById('mstGridBody').children[i];
                row.querySelector('[data-field="mst_id"]').value = data.mst_id;
                row.querySelector('[data-field="ports"]').value = data.ports;
                row.querySelector('[data-field="fda"]').value = data.fda;
                row.querySelector('[data-field="fsa"]').value = data.fsa;
                row.querySelector('[data-field="spec"]').value = data.spec;
                row.querySelector('[data-field="wkt_geom"]').value = data.wkt_geom;
            });
            
            // Load LGX
            clearLGXGrid();
            lgxSampleData.forEach((data, i) => {
                addLGXRows(1);
                const row = document.getElementById('lgxGridBody').children[i];
                row.querySelector('[data-field="fiber"]').value = data.fiber;
                row.querySelector('[data-field="port"]').value = data.port;
                row.querySelector('[data-field="mst_hub"]').value = data.mst_hub;
                row.querySelector('[data-field="address"]').value = data.address;
                row.querySelector('[data-field="customer_id"]').value = data.customer_id;
            });
            
            detectGeoData('cable');
            showNotification('Sample Data Loaded', 'Full network sample data has been loaded', 'success');
        }
        
        function loadSpliceSample() {
            clearSpliceGrid();
            const sampleData = [
                {fondid: 'AUGS-2_FDA_4_SP_15', fda: 'VAAUGS0204', fsa: 'VA-AUGS-02', placement: 'AERIAL', spec: 'X-2S', ap_type: 'SPLICE', wkt_geom: 'POINT(-79.05860428536733764 38.33579500580574262)'},
                {fondid: 'AUGS-2_FDA_7_SP_1', fda: 'VAAUGS0207', fsa: 'VA-AUGS-02', placement: 'AERIAL', spec: 'X-2', ap_type: 'SPLICE', wkt_geom: 'POINT(-79.095869 38.316235)'}
            ];
            
            sampleData.forEach((data, i) => {
                addSpliceRows(1);
                const row = document.getElementById('spliceGridBody').children[i];
                row.querySelector('[data-field="fondid"]').value = data.fondid;
                row.querySelector('[data-field="fda"]').value = data.fda;
                row.querySelector('[data-field="fsa"]').value = data.fsa;
                row.querySelector('[data-field="placement"]').value = data.placement;
                row.querySelector('[data-field="spec"]').value = data.spec;
                row.querySelector('[data-field="ap_type"]').value = data.ap_type;
                row.querySelector('[data-field="wkt_geom"]').value = data.wkt_geom;
            });
            
            detectGeoData('splice');
        }
        
        // Validation functions
        function validateCableInput(input) {
            const field = input.getAttribute('data-field');
            const value = input.value.trim();
            
            input.classList.remove('valid', 'error');
            
            if (value) {
                if (field === 'size' && isNaN(value)) {
                    input.classList.add('error');
                } else {
                    input.classList.add('valid');
                }
            }
            
            updateProcessButton();
        }
        
        function validateSpliceInput(input) {
            const field = input.getAttribute('data-field');
            const value = input.value.trim();
            
            input.classList.remove('valid', 'error');
            
            if (value) {
                input.classList.add('valid');
            }
            
            updateProcessButton();
        }
        
        function detectGeoData(type) {
            let hasGeo = false;
            
            if (type === 'cable') {
                const rows = document.getElementById('cableGridBody').children;
                for (let row of rows) {
                    const wkt = row.querySelector('[data-field="wkt_geom"]').value;
                    if (wkt && (wkt.includes('LINESTRING') || wkt.includes('MULTILINESTRING'))) {
                        hasGeo = true;
                        break;
                    }
                }
                
                const status = document.getElementById('cableGeoStatus');
                if (hasGeo) {
                    status.classList.add('show');
                } else {
                    status.classList.remove('show');
                }
            } else if (type === 'splice') {
                const rows = document.getElementById('spliceGridBody').children;
                for (let row of rows) {
                    const wkt = row.querySelector('[data-field="wkt_geom"]').value;
                    if (wkt && wkt.includes('POINT')) {
                        hasGeo = true;
                        break;
                    }
                }
                
                const status = document.getElementById('spliceGeoStatus');
                if (hasGeo) {
                    status.classList.add('show');
                } else {
                    status.classList.remove('show');
                }
            }
        }
        
        function updateProcessButton() {
            const cableRows = document.getElementById('cableGridBody').children;
            const spliceRows = document.getElementById('spliceGridBody').children;
            
            let validCables = 0;
            let validSplices = 0;
            
            for (let row of cableRows) {
                const fondid = row.querySelector('[data-field="fondid"]').value;
                const type = row.querySelector('[data-field="cable_type"]').value;
                if (fondid && type) validCables++;
            }
            
            for (let row of spliceRows) {
                const fondid = row.querySelector('[data-field="fondid"]').value;
                if (fondid) validSplices++;
            }
            
            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = validCables === 0;
        }
        
        // =====================================================================
        // PASTE HANDLING - Smart Paste Integration
        // =====================================================================
        document.addEventListener('paste', function(e) {
            const activeElement = document.activeElement;
            if (!activeElement || !activeElement.classList.contains('grid-input')) return;
            
            e.preventDefault();
            
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedData = clipboardData.getData('text');
            
            // Always use Smart Paste for multi-cell data
            if (pastedData.includes('\n') || pastedData.includes('\t')) {
                // Determine which grid we're pasting into
                const gridRow = activeElement.closest('tr');
                const tbody = gridRow.parentElement;
                let gridType = '';
                
                if (tbody.id === 'cableGridBody') gridType = 'cable';
                else if (tbody.id === 'spliceGridBody') gridType = 'splice';
                else if (tbody.id === 'cabinetGridBody') gridType = 'cabinet';
                else if (tbody.id === 'mstGridBody') gridType = 'mst';
                else if (tbody.id === 'lgxGridBody') gridType = 'lgx';
                
                if (gridType) {
                    SmartPaste.initiatePaste(pastedData, gridType);
                }
            } else {
                // Single cell paste
                activeElement.value = pastedData.trim();
                activeElement.dispatchEvent(new Event('input'));
            }
        });
// =====================================================================
        // GEM FIBER PARSING LOGIC - The Heart of the System! 💎
        // =====================================================================
        class FiberRange {
            constructor(startFiber, endFiber, isDeadFiber = false, tierDesignation = 'T2') {
                this.startFiber = startFiber;
                this.endFiber = endFiber;
                this.isDeadFiber = isDeadFiber;
                this.tierDesignation = tierDesignation;
            }
        }
        
        class PortRange {
            constructor(startPort, endPort, facilityName, tierDesignation = 'T2', isFacilityOnly = false) {
                this.startPort = startPort;
                this.endPort = endPort;
                this.facilityName = facilityName;
                this.tierDesignation = tierDesignation;
                this.isFacilityOnly = isFacilityOnly;
            }
        }
        
        class ParsedCableData {
            constructor() {
                this.fiberRanges = [];
                this.portRanges = [];
                this.hasErrors = false;
                this.errorMessages = '';
                this.totalLitFibers = 0;
                this.totalLitPorts = 0;
            }
        }
        
        function parseCableCt(cableCt, cableId) {
            const result = new ParsedCableData();
            
            // Split by semicolon to get main segments
            const segments = cableCt.split(';');
            
            for (let segment of segments) {
                segment = segment.trim();
                if (segment !== '') {
                    processCableSegment(segment, result, cableId);
                }
            }
            
            // Validate parsed data
            validateParsedData(result, cableId);
            
            return result;
        }
        
        function processCableSegment(segment, result, cableId) {
            // Clean up newline characters
            let processedSegment = segment.replace(/[\r\n]/g, ' ').trim();
            
            // Extract tier designation
            const tierDesignation = extractTierDesignation(processedSegment);
            
            // Check if this is a dead fiber segment
            const isDeadSegment = processedSegment.toUpperCase().includes('XD');
            
            if (isDeadSegment) {
                processDeadFiberSegment(processedSegment, result, tierDesignation, cableId);
            } else {
                processActiveFiberSegment(processedSegment, result, tierDesignation, cableId);
            }
        }
        
        function extractTierDesignation(segment) {
            const upperSegment = segment.toUpperCase();
            
            // Check for T1_TAIL first (special case)
            if (upperSegment.includes('T1_TAIL')) {
                return 'T1_TAIL';
            }
            
            // Check for T1-T5
            for (let i = 5; i >= 1; i--) {
                if (upperSegment.includes(`T${i}`)) {
                    return `T${i}`;
                }
            }
            
            return 'T2'; // Default to distribution
        }
        
        function processDeadFiberSegment(segment, result, tierDesignation, cableId) {
            let cleanedSegment = segment.trim();
            
            // Remove tier designation
            if (tierDesignation !== 'T2') {
                cleanedSegment = cleanedSegment.replace(new RegExp(tierDesignation, 'gi'), '');
            }
            cleanedSegment = cleanedSegment.trim();
            
            // Remove XD/xd - handle various formats
            cleanedSegment = cleanedSegment.replace(/\bXD\b/gi, '').trim();
            cleanedSegment = cleanedSegment.replace(/\bxd\b/gi, '').trim();
            
            // Parse fiber ranges (can be comma-separated like "1-4, 7-10")
            if (cleanedSegment !== '') {
                const ranges = cleanedSegment.split(',');
                for (let range of ranges) {
                    range = range.trim();
                    if (range !== '' && (range.includes('-') || !isNaN(range))) {
                        addFiberRange(result, range, true, tierDesignation);
                    }
                }
            }
        }
        
        function processActiveFiberSegment(segment, result, tierDesignation, cableId) {
            const { fiberRanges, facilityName, portRanges } = extractRangesFromSegment(segment, tierDesignation);
            
            // Add fiber ranges
            for (let range of fiberRanges) {
                if (range.trim() !== '') {
                    addFiberRange(result, range, false, tierDesignation);
                }
            }
            
            // Handle port ranges
            if (facilityName && portRanges.length > 0) {
                for (let range of portRanges) {
                    if (range.trim() !== '') {
                        addPortRange(result, range, facilityName, tierDesignation);
                    }
                }
            }
        }
        
        function extractRangesFromSegment(segment, tierDesignation) {
            let cleanSegment = segment.replace(new RegExp(tierDesignation, 'gi'), '').trim();
            
            // Split and find facility name
            const parts = cleanSegment.split(' ');
            let facilityName = '';
            let facilityIndex = -1;
            let fiberRanges = [];
            let portRanges = [];
            
            // Find facility name (contains letters)
            for (let i = 0; i < parts.length; i++) {
                if (/[a-zA-Z]/.test(parts[i]) && !parts[i].includes('-')) {
                    facilityIndex = i;
                    // Collect all parts that form the facility name
                    while (i < parts.length && /[a-zA-Z_-]/.test(parts[i])) {
                        facilityName += (facilityName ? ' ' : '') + parts[i];
                        i++;
                    }
                    break;
                }
            }
            
            // Extract ranges
            if (facilityIndex >= 0) {
                // Fiber ranges are before facility
                for (let i = 0; i < facilityIndex; i++) {
                    if (parts[i].includes('-') || !isNaN(parts[i])) {
                        fiberRanges.push(parts[i]);
                    }
                }
                
                // Port ranges are after facility
                for (let i = facilityIndex + facilityName.split(' ').length; i < parts.length; i++) {
                    if (parts[i] && (parts[i].includes('-') || !isNaN(parts[i]))) {
                        portRanges.push(parts[i]);
                    }
                }
            } else {
                // No facility - all are fiber ranges
                fiberRanges = parts.filter(p => p.includes('-') || !isNaN(p));
            }
            
            return { fiberRanges, facilityName, portRanges };
        }
        
        function addFiberRange(result, rangeText, isDead, tierDesignation) {
            rangeText = rangeText.trim();
            let startFiber, endFiber;
            
            if (rangeText.includes('-')) {
                const parts = rangeText.split('-');
                startFiber = parseInt(parts[0]);
                endFiber = parseInt(parts[1]);
            } else if (!isNaN(rangeText)) {
                startFiber = parseInt(rangeText);
                endFiber = parseInt(rangeText);
            } else {
                return;
            }
            
            if (!isNaN(startFiber) && !isNaN(endFiber)) {
                const newRange = new FiberRange(startFiber, endFiber, isDead, tierDesignation);
                result.fiberRanges.push(newRange);
                
                if (!isDead) {
                    result.totalLitFibers += (endFiber - startFiber + 1);
                }
            }
        }
        
        function addPortRange(result, rangeText, facilityName, tierDesignation) {
            rangeText = rangeText.trim();
            let startPort, endPort;
            
            if (rangeText.includes('-')) {
                const parts = rangeText.split('-');
                startPort = parseInt(parts[0]);
                endPort = parseInt(parts[1]);
            } else if (!isNaN(rangeText)) {
                startPort = parseInt(rangeText);
                endPort = parseInt(rangeText);
            } else {
                return;
            }
            
            if (!isNaN(startPort) && !isNaN(endPort)) {
                const newRange = new PortRange(startPort, endPort, facilityName, tierDesignation, false);
                result.portRanges.push(newRange);
                result.totalLitPorts += (endPort - startPort + 1);
            }
        }
        
        function validateParsedData(result, cableId) {
            // Check if lit fiber count matches lit port count
            if (result.totalLitFibers !== result.totalLitPorts && result.totalLitPorts > 0) {
                result.hasErrors = true;
                result.errorMessages += `\nMISMATCH: Cable ${cableId} has ${result.totalLitFibers} lit fibers but ${result.totalLitPorts} lit ports`;
            }
        }
        
        // =====================================================================
        // LIGHT SOURCE CABLE DETECTION - Finding the Origin! 💡
        // =====================================================================
        function identifyLightSourceCable(cables) {
            let maxPortCount = 0;
            let lightSource = null;
            
            // First, check if we have an active cabinet in the data
            const activeCabinet = cabinetData.find(cab => 
                cab.type === 'ACTIVE' || cab.cabinet_id.startsWith('FAC-')
            );
            
            if (activeCabinet) {
                // Look for cables connected to the active cabinet's LGX
                for (let cable of cables) {
                    if (cable.cable_ct) {
                        // Check if cable_ct mentions AUGUSTA LGX or similar central facility
                        if (cable.cable_ct.toUpperCase().includes('AUGUSTA LGX') || 
                            cable.cable_ct.toUpperCase().includes('LGX')) {
                            const parsed = parseCableCt(cable.cable_ct, cable.fondid);
                            if (parsed.totalLitPorts > maxPortCount) {
                                maxPortCount = parsed.totalLitPorts;
                                lightSource = cable.fondid;
                            }
                        }
                    }
                }
            }
            
            // If not found by LGX reference, use cable with most ports
            if (!lightSource) {
                for (let cable of cables) {
                    if (cable.cable_ct) {
                        const parsed = parseCableCt(cable.cable_ct, cable.fondid);
                        if (parsed.totalLitPorts > maxPortCount) {
                            maxPortCount = parsed.totalLitPorts;
                            lightSource = cable.fondid;
                        }
                    }
                }
            }
            
            // If still not found, use FEEDER with highest capacity
            if (!lightSource) {
                let maxCapacity = 0;
                for (let cable of cables) {
                    if (cable.cable_type === 'FEEDER' && parseInt(cable.size) > maxCapacity) {
                        maxCapacity = parseInt(cable.size);
                        lightSource = cable.fondid;
                    }
                }
            }
            
            console.log('Light source cable identified:', lightSource, 'with', maxPortCount, 'ports');
            return lightSource;
        }
        
        // =====================================================================
        // PROCESS NETWORK DATA - Where Everything Comes Together! 🚀
        // =====================================================================
        function processData() {
            console.log('Processing network data...');
            
            // Collect data from all grids
            cableData = collectGridData('cable');
            spliceData = collectGridData('splice');
            cabinetData = collectGridData('cabinet');
            mstData = collectGridData('mst');
            lgxData = collectGridData('lgx');
            
            if (cableData.length === 0) {
                showNotification('No Data', 'Please enter cable data before processing', 'warning');
                return;
            }
            
            // Save state for undo
            saveHistoryState();
            
            // Reset processing state
            parsingErrors = [];
            processedConnections = [];
            cableMap = {};
            deadFiberMap = {};
            
            // Identify light source cable
            lightSourceCable = identifyLightSourceCable(cableData);
            
            // Show GEM status
            if (lightSourceCable) {
                document.getElementById('gemStatus').classList.add('show');
                document.getElementById('gemDetails').textContent = `Light source: ${lightSourceCable}`;
            }
            
            // Build cable map
            cableMap = mapCablesToPorts(cableData);
            
            // Process connections
            processedConnections = processActiveConnections(cableData);
            
            // Store processed network
            window.processedNetwork = {
                cables: cableData,
                splices: spliceData,
                cabinets: cabinetData,
                msts: mstData,
                lgx: lgxData,
                connections: processedConnections,
                lightSource: lightSourceCable,
                deadFibers: deadFiberMap
            };
            
            console.log('Network processed:', window.processedNetwork);
            
            // NEW: Perform cable-to-splice snapping
            if (spliceData.length > 0) {
                console.log('🧲 Performing cable-to-splice snapping...');
                const snapResults = window.cableSnapping.snapAllCables();
                
                // Show snapping results
                if (snapResults && snapResults.length > 0) {
                    showNotification('Snapping Complete', 
                        `Successfully snapped ${snapResults.length} cables to splice points!`, 
                        'success');
                }
            }
            
            // Process service locations from LGX data
            if (lgxData.length > 0) {
                processLGXData();
            }
            
            // Switch to map view
            switchTab('map');
            
            // Render network on map with snapped connections
            setTimeout(() => {
                if (typeof L !== 'undefined') {
                    renderNetworkOnMap();
                } else {
                    console.error('Leaflet still not loaded!');
                    showNotification('Map Error', 'Map library not loaded. Please refresh and try again.', 'error');
                }
            }, 500);
            
            // Validate the snapped connections
            const validationIssues = window.cableSnapping.validateSpliceConnections();
            if (validationIssues.length > 0) {
                console.log('⚠️ Validation issues found:', validationIssues);
            }
            
            showNotification('Processing Complete', 
                `Processed ${cableData.length} cables with ${processedConnections.length} connections`, 
                'success');
        }
        
        function collectGridData(gridType) {
            const data = [];
            const tbody = document.getElementById(`${gridType}GridBody`);
            if (!tbody) return data;
            
            const rows = tbody.children;
            for (let row of rows) {
                const rowData = {};
                const inputs = row.querySelectorAll('.grid-input');
                let hasData = false;
                
                inputs.forEach(input => {
                    const field = input.getAttribute('data-field');
                    const value = input.value.trim();
                    if (value) hasData = true;
                    rowData[field] = value;
                });
                
                if (hasData) data.push(rowData);
            }
            
            return data;
        }
        
        function processLGXData() {
            // Process LGX entries to create service locations
            serviceLocationData = lgxData.map(entry => ({
                ...entry,
                type: 'service_location'
            }));
        }
        
        function restoreGrid(gridType, data) {
            // Clear grid
            const tbody = document.getElementById(`${gridType}GridBody`);
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Add rows and fill data
            data.forEach((rowData, index) => {
                // Add row based on type
                if (gridType === 'cable') addCableRows(1);
                else if (gridType === 'splice') addSpliceRows(1);
                else if (gridType === 'cabinet') addCabinetRows(1);
                else if (gridType === 'mst') addMSTRows(1);
                else if (gridType === 'lgx') addLGXRows(1);
                
                // Fill data
                const row = tbody.children[index];
                if (row) {
                    Object.keys(rowData).forEach(field => {
                        const input = row.querySelector(`[data-field="${field}"]`);
                        if (input) input.value = rowData[field];
                    });
                }
            });
            
            // Update row counts
            if (gridType === 'cable') updateCableRowCount();
            else if (gridType === 'splice') updateSpliceRowCount();
        }
        
        function saveProject() {
            const projectData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                data: {
                    cables: collectGridData('cable'),
                    splices: collectGridData('splice'),
                    cabinets: collectGridData('cabinet'),
                    msts: collectGridData('mst'),
                    lgx: collectGridData('lgx')
                },
                metadata: {
                    lightSource: lightSourceCable,
                    processedConnections: processedConnections
                }
            };
            
            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Phoenix_Fiber_Project_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Project Saved', 'Project data saved to file', 'success');
        }
        
        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        // Validate project data
                        if (!projectData.version || !projectData.data) {
                            throw new Error('Invalid project file format');
                        }
                        
                        // Clear existing data
                        clearAllGrids();
                        
                        // Restore data
                        if (projectData.data.cables) {
                            restoreGrid('cable', projectData.data.cables);
                        }
                        if (projectData.data.splices) {
                            restoreGrid('splice', projectData.data.splices);
                        }
                        if (projectData.data.cabinets) {
                            restoreGrid('cabinet', projectData.data.cabinets);
                        }
                        if (projectData.data.msts) {
                            restoreGrid('mst', projectData.data.msts);
                        }
                        if (projectData.data.lgx) {
                            restoreGrid('lgx', projectData.data.lgx);
                        }
                        
                        // Detect geo data
                        detectGeoData('cable');
                        detectGeoData('splice');
                        
                        showNotification('Project Loaded', 'Project data loaded successfully', 'success');
                        
                        // Save state for undo
                        saveHistoryState();
                        
                    } catch (error) {
                        console.error('Failed to load project:', error);
                        showNotification('Load Failed', 'Error loading project file: ' + error.message, 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function clearAllGrids() {
            clearCableGrid();
            clearSpliceGrid();
            clearCabinetGrid();
            clearMSTGrid();
            clearLGXGrid();
        }
        
        function mapCablesToPorts(cables) {
            const map = {};
            const deadFibers = {};
            
            for (let cable of cables) {
                if (!cable.cable_ct) continue;
                
                const parsedData = parseCableCt(cable.cable_ct, cable.fondid);
                
                // Track dead fibers
                deadFibers[cable.fondid] = parsedData.fiberRanges.filter(r => r.isDeadFiber);
                
                // Map ports if not light source
                if (cable.fondid !== lightSourceCable) {
                    for (let i = 0; i < parsedData.fiberRanges.length; i++) {
                        const fiberRange = parsedData.fiberRanges[i];
                        if (!fiberRange.isDeadFiber && i < parsedData.portRanges.length) {
                            const portRange = parsedData.portRanges[i];
                            
                            const fiberCount = fiberRange.endFiber - fiberRange.startFiber + 1;
                            const portCount = portRange.endPort - portRange.startPort + 1;
                            
                            for (let k = 0; k < Math.min(fiberCount, portCount); k++) {
                                const fiber = fiberRange.startFiber + k;
                                const port = portRange.startPort + k;
                                
                                map[`${port}_${fiberRange.tierDesignation}`] = {
                                    cable: cable.fondid,
                                    fiber: fiber,
                                    tier: fiberRange.tierDesignation
                                };
                            }
                        }
                    }
                }
            }
            
            deadFiberMap = deadFibers;
            return map;
        }
        
        function processActiveConnections(cables) {
            const connections = [];
            
            for (let cable of cables) {
                if (!cable.cable_ct || cable.fondid === lightSourceCable) continue;
                
                const parsedData = parseCableCt(cable.cable_ct, cable.fondid);
                
                for (let i = 0; i < parsedData.fiberRanges.length; i++) {
                    const fiberRange = parsedData.fiberRanges[i];
                    if (!fiberRange.isDeadFiber && i < parsedData.portRanges.length) {
                        const portRange = parsedData.portRanges[i];
                        
                        for (let k = 0; k <= Math.min(fiberRange.endFiber - fiberRange.startFiber, portRange.endPort - portRange.startPort); k++) {
                            const fiberIn = fiberRange.startFiber + k;
                            const port = portRange.startPort + k;
                            
                            // Find connected cable
                            const key = `${port}_${fiberRange.tierDesignation}`;
                            const mapped = cableMap[key];
                            
                            if (mapped && mapped.cable !== cable.fondid) {
                                connections.push({
                                    cableIn: cable.fondid,
                                    fiberIn: fiberIn,
                                    cableOut: mapped.cable,
                                    fiberOut: mapped.fiber,
                                    port: port,
                                    tier: fiberRange.tierDesignation,
                                    type: 'SPLICE'
                                });
                            }
                        }
                    }
                }
            }
            
            return connections;
        }
        
        // =====================================================================
        // MAP FUNCTIONS - Visualizing the Network! 🗺️
        // =====================================================================
        function initializeMap() {
            if (map) return;
            
            // Check if Leaflet is available
            if (typeof L === 'undefined') {
                console.error('Leaflet is not loaded!');
                showNotification('Map Error', 'Map library failed to load. Please refresh the page.', 'error');
                return;
            }
            
            console.log('Initializing map...');
            
            try {
                // Create map centered on Augusta County, Virginia
                map = L.map('networkMap').setView([38.325, -79.075], 13);
                
                // Add tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(map);
                
                // Initialize marker cluster group
                networkLayers.customerCluster = L.markerClusterGroup({
                    maxClusterRadius: 40,
                    iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount();
                        return L.divIcon({
                            html: `<div style="background: var(--success); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px;">${count}</div>`,
                            className: 'customer-cluster-icon',
                            iconSize: [30, 30]
                        });
                    }
                });
                
                map.addLayer(networkLayers.customerCluster);
                
                console.log('Map initialized successfully');
            } catch (error) {
                console.error('Failed to initialize map:', error);
                showNotification('Map Error', 'Failed to initialize map: ' + error.message, 'error');
            }
        }
        
        function renderNetworkOnMap() {
            if (!map || !window.processedNetwork) return;
            
            console.log('Rendering network on map...');
            
            // Clear existing layers
            clearMapLayers();
            
            // Update stats
            updateNetworkStats();
            
            // Render cables with snapped connections
            renderCablesWithSnapping();
            
            // Render splices
            renderSplices();
            
            // Render cabinets
            renderCabinets();
            
            // Render MSTs
            renderMSTs();
            
            // Render service locations
            renderServiceLocations();
            
            // Fit map to network bounds
            zoomToFit();
        }
        
        function clearMapLayers() {
            // Clear cable layers
            for (let id in networkLayers.cables) {
                map.removeLayer(networkLayers.cables[id]);
            }
            networkLayers.cables = {};
            
            // Clear splice layers
            for (let id in networkLayers.splices) {
                map.removeLayer(networkLayers.splices[id]);
            }
            networkLayers.splices = {};
            
            // Clear other layers
            for (let id in networkLayers.cabinets) {
                map.removeLayer(networkLayers.cabinets[id]);
            }
            networkLayers.cabinets = {};
            
            for (let id in networkLayers.msts) {
                map.removeLayer(networkLayers.msts[id]);
            }
            networkLayers.msts = {};
            
            // Clear customer cluster
            networkLayers.customerCluster.clearLayers();
            
            // Clear snap indicators
            networkLayers.snapIndicators.forEach(layer => map.removeLayer(layer));
            networkLayers.snapIndicators = [];
        }
        
        /**
         * Enhanced renderCables function that uses snapped geometry
         */
        function renderCablesWithSnapping() {
            const cables = window.processedNetwork.cables;
            
            cables.forEach(cable => {
                if (cable.wkt_geom) {
                    // Use snapped geometry if available, otherwise use original
                    const coords = cable._snappedGeometry || parseGeometry(cable.wkt_geom);
                    
                    if (coords && coords.length > 0) {
                        const color = getCableColor(cable.cable_type);
                        const weight = cable.fondid === lightSourceCable ? 6 : 4;
                        
                        const polyline = L.polyline(coords, {
                            color: color,
                            weight: weight,
                            opacity: 0.8
                        }).addTo(map);
                        
                        // Enhanced popup with connection info
                        const connections = findConnectedSplices(cable.fondid);
                        const geomType = cable.wkt_geom.match(/^[A-Z]+/)?.[0] || 'UNKNOWN';
                        
                        const popupContent = `
                            <div style="min-width: 250px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: var(--primary);">${cable.fondid}</h4>
                                <div><strong>Type:</strong> ${cable.cable_type}</div>
                                <div><strong>Size:</strong> ${cable.size} fibers</div>
                                <div><strong>Cable Count:</strong> ${cable.cable_ct || 'N/A'}</div>
                                <div><strong>Geometry:</strong> ${geomType}</div>
                                ${cable._snappedGeometry ? '<div style="color: var(--success);">✅ Snapped to splices</div>' : ''}
                                ${cable.fondid === lightSourceCable ? '<div style="color: var(--warning); font-weight: bold; margin-top: 0.5rem;">⚡ Light Source Cable</div>' : ''}
                                ${connections.length > 0 ? `
                                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border);">
                                        <strong>Connected Splices:</strong>
                                        ${connections.map(s => `<div style="color: var(--text-light); font-size: 0.875rem;">• ${s}</div>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                        polyline.bindPopup(popupContent);
                        
                        networkLayers.cables[cable.fondid] = polyline;
                    }
                }
            });
        }
        
        function renderSplices() {
            const splices = window.processedNetwork.splices;
            
            splices.forEach(splice => {
                if (splice.wkt_geom && splice.wkt_geom.includes('POINT')) {
                    const coords = parsePoint(splice.wkt_geom);
                    if (coords) {
                        // Check if this splice has connections
                        const connectedCables = window.cableSnapping.findConnectedCables(splice.fondid);
                        const hasConnections = connectedCables.length > 0;
                        
                        const marker = L.circleMarker(coords, {
                            radius: hasConnections ? 10 : 8,
                            fillColor: hasConnections ? '#10b981' : '#FF6B35',
                            color: 'white',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8
                        }).addTo(map);
                        
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: var(--primary);">${splice.fondid}</h4>
                                <div><strong>FDA:</strong> ${splice.fda}</div>
                                <div><strong>FSA:</strong> ${splice.fsa}</div>
                                <div><strong>Placement:</strong> ${splice.placement}</div>
                                <div><strong>Spec:</strong> ${splice.spec}</div>
                                ${hasConnections ? `
                                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border);">
                                        <strong style="color: var(--success);">Connected Cables (${connectedCables.length}):</strong>
                                        ${connectedCables.map(c => `<div style="font-size: 0.875rem;">• ${c.cableId} (${c.cableType})</div>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                        marker.bindPopup(popupContent);
                        
                        networkLayers.splices[splice.fondid] = marker;
                    }
                }
            });
        }
        
        function renderCabinets() {
            const cabinets = window.processedNetwork.cabinets;
            
            cabinets.forEach(cabinet => {
                if (cabinet.wkt_geom && cabinet.wkt_geom.includes('POINT')) {
                    const coords = parsePoint(cabinet.wkt_geom);
                    if (coords) {
                        // Determine cabinet type from naming convention or type field
                        const isActive = cabinet.type === 'ACTIVE' || 
                                       cabinet.cabinet_id.startsWith('FAC-') ||
                                       cabinet.spec === 'FAC-3200';
                        
                        const color = isActive ? '#ef4444' : '#f59e0b';
                        const label = isActive ? 'A' : 'P';
                        
                        const icon = L.divIcon({
                            html: `<div style="background: ${color}; color: white; width: 32px; height: 32px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${label}</div>`,
                            className: 'cabinet-icon',
                            iconSize: [32, 32]
                        });
                        
                        const marker = L.marker(coords, { icon }).addTo(map);
                        
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: ${color};">${cabinet.cabinet_id}</h4>
                                <div><strong>Type:</strong> ${isActive ? 'ACTIVE' : 'PASSIVE'} CABINET</div>
                                <div><strong>FSA:</strong> ${cabinet.fsa}</div>
                                <div><strong>FDA:</strong> ${cabinet.fda}</div>
                                ${cabinet.cab_size ? `<div><strong>Size:</strong> ${cabinet.cab_size} ports</div>` : ''}
                                ${cabinet.spec ? `<div><strong>Spec:</strong> ${cabinet.spec}</div>` : ''}
                            </div>
                        `;
                        marker.bindPopup(popupContent);
                        
                        networkLayers.cabinets[cabinet.cabinet_id] = marker;
                    }
                }
            });
        }
        
        function renderMSTs() {
            const msts = window.processedNetwork.msts;
            
            msts.forEach(mst => {
                if (mst.wkt_geom && mst.wkt_geom.includes('POINT')) {
                    const coords = parsePoint(mst.wkt_geom);
                    if (coords) {
                        const marker = L.circleMarker(coords, {
                            radius: 6,
                            fillColor: '#3b82f6',
                            color: 'white',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8
                        }).addTo(map);
                        
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: var(--info);">${mst.mst_id}</h4>
                                <div><strong>Ports:</strong> ${mst.ports}</div>
                                <div><strong>FDA:</strong> ${mst.fda}</div>
                                ${mst.fsa ? `<div><strong>FSA:</strong> ${mst.fsa}</div>` : ''}
                                ${mst.spec ? `<div><strong>Spec:</strong> ${mst.spec}</div>` : ''}
                            </div>
                        `;
                        marker.bindPopup(popupContent);
                        
                        networkLayers.msts[mst.mst_id] = marker;
                    }
                }
            });
        }
        
        function renderServiceLocations() {
            const lgxEntries = window.processedNetwork.lgx;
            const msts = window.processedNetwork.msts;
            const addressMap = {};
            
            // Group by address
            lgxEntries.forEach(entry => {
                if (entry.address) {
                    if (!addressMap[entry.address]) {
                        addressMap[entry.address] = [];
                    }
                    addressMap[entry.address].push(entry);
                }
            });
            
            // Create markers for unique addresses
            Object.keys(addressMap).forEach(address => {
                const entries = addressMap[address];
                const mstHub = entries[0].mst_hub;
                
                // Find MST location
                const mst = msts.find(m => m.mst_id === mstHub);
                let lat, lng;
                
                if (mst && mst.wkt_geom) {
                    // Place near MST location with slight offset
                    const mstCoords = parsePoint(mst.wkt_geom);
                    if (mstCoords) {
                        // Add small random offset to avoid overlapping
                        lat = mstCoords[0] + (Math.random() - 0.5) * 0.002;
                        lng = mstCoords[1] + (Math.random() - 0.5) * 0.002;
                    }
                } else {
                    // Fallback to general area
                    lat = 38.325 + (Math.random() - 0.5) * 0.02;
                    lng = -79.075 + (Math.random() - 0.5) * 0.02;
                }
                
                const hasCustomer = entries.some(e => e.customer_id);
                const color = hasCustomer ? '#10b981' : '#64748b';
                
                const marker = L.circleMarker([lat, lng], {
                    radius: 4,
                    fillColor: color,
                    color: 'white',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                
                const popupContent = `
                    <div style="min-width: 250px;">
                        <h4 style="margin: 0 0 0.5rem 0; color: var(--text);">${address}</h4>
                        ${entries.map(e => `
                            <div style="padding: 0.25rem 0; border-top: 1px solid var(--border);">
                                <div><strong>Port:</strong> ${e.port} | <strong>Fiber:</strong> ${e.fiber}</div>
                                <div><strong>MST:</strong> ${e.mst_hub}</div>
                                ${e.customer_id ? `<div style="color: var(--success);"><strong>Customer:</strong> ${e.customer_id}</div>` : '<div style="color: var(--text-light);">Unassigned</div>'}
                            </div>
                        `).join('')}
                    </div>
                `;
                marker.bindPopup(popupContent);
                
                networkLayers.customerCluster.addLayer(marker);
            });
        }
        
        function getCableColor(type) {
            const colors = {
                'FEEDER': '#3b82f6',        // T3 - Blue
                'DISTRIBUTION': '#10b981',   // T2 - Green
                'TAIL': '#8b5cf6',          // Generic tail
                'MST TAIL': '#f59e0b',      // T1_TAIL - Orange
                'DROP': '#ef4444'           // T1 - Red
            };
            return colors[type] || '#6b7280';
        }
        
        function parseLineString(wkt) {
            const coords = [];
            const match = wkt.match(/LINESTRING\s*\(\s*(.+)\s*\)/);
            if (match) {
                const pairs = match[1].split(',');
                pairs.forEach(pair => {
                    const [lng, lat] = pair.trim().split(' ').map(parseFloat);
                    coords.push([lat, lng]);
                });
            }
            return coords;
        }
        
        function parsePoint(wkt) {
            const match = wkt.match(/POINT\s*\(\s*(.+)\s*\)/);
            if (match) {
                const [lng, lat] = match[1].trim().split(' ').map(parseFloat);
                return [lat, lng];
            }
            return null;
        }
        
        function updateNetworkStats() {
            const network = window.processedNetwork;
            
            document.getElementById('statCables').textContent = network.cables.length;
            document.getElementById('statSplices').textContent = network.splices.length;
            document.getElementById('statCabinets').textContent = network.cabinets.length;
            document.getElementById('statMSTs').textContent = network.msts.length;
            
            // Count unique addresses
            const uniqueAddresses = new Set(network.lgx.map(e => e.address).filter(a => a));
            document.getElementById('statCustomers').textContent = uniqueAddresses.size;
            
            // Update FSA/FDA info
            const fsaSet = new Set();
            const fdaSet = new Set();
            
            // Collect from all sources
            [...network.splices, ...network.cabinets, ...network.msts].forEach(item => {
                if (item.fsa) fsaSet.add(item.fsa);
                if (item.fda) fdaSet.add(item.fda);
            });
            
            let infoText = '';
            if (fsaSet.size > 0) {
                infoText += `FSA: ${Array.from(fsaSet).join(', ')}`;
            }
            if (fdaSet.size > 0) {
                infoText += infoText ? ' | ' : '';
                infoText += `FDAs: ${Array.from(fdaSet).join(', ')}`;
            }
            
            document.getElementById('fsaInfo').textContent = infoText;
            
            // Update light source info
            if (network.lightSource) {
                const lightCable = network.cables.find(c => c.fondid === network.lightSource);
                document.getElementById('lightSourceInfo').textContent = 
                    `Light Source: ${network.lightSource} (${lightCable?.size || '?'} fibers)`;
            }
        }
        
        function zoomToFit() {
            if (!map) return;
            
            const bounds = [];
            
            // Add cable coordinates
            for (let id in networkLayers.cables) {
                bounds.push(...networkLayers.cables[id].getLatLngs());
            }
            
            // Add splice coordinates
            for (let id in networkLayers.splices) {
                bounds.push(networkLayers.splices[id].getLatLng());
            }
            
            // Add cabinet coordinates
            for (let id in networkLayers.cabinets) {
                bounds.push(networkLayers.cabinets[id].getLatLng());
            }
            
            // Add MST coordinates
            for (let id in networkLayers.msts) {
                bounds.push(networkLayers.msts[id].getLatLng());
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // =====================================================================
        // MAP TOOLS - Interactive Features! 🛠️
        // =====================================================================
        function setMapTool(tool) {
            currentMapTool = tool;
            
            // Update UI
            document.querySelectorAll('.map-tool').forEach(t => t.classList.remove('active'));
            document.getElementById(`${tool}Tool`).classList.add('active');
            
            // Show/hide customer trace panel
            if (tool === 'customerTrace') {
                document.getElementById('customerTracePanel').classList.add('show');
            } else {
                document.getElementById('customerTracePanel').classList.remove('show');
            }
        }
        
        function performManualSnap() {
            const results = window.cableSnapping.snapAllCables();
            if (results && results.length > 0) {
                showNotification('Snap Complete!', 
                    `Connected ${results.length} cables to splice points`, 
                    'success');
                // Refresh the map
                renderNetworkOnMap();
            } else {
                showNotification('No Snaps Found', 
                    'No cables found within snapping distance of splice points', 
                    'info');
            }
        }
        
        function refreshMap() {
            if (map && window.processedNetwork) {
                renderNetworkOnMap();
                showNotification('Map Refreshed', 'Network view has been updated', 'info');
            }
        }
        
        function traceCustomerPath() {
            const address = document.getElementById('customerAddressInput').value.trim();
            if (!address) {
                showNotification('Error', 'Please enter a customer address', 'error');
                return;
            }
            
            const network = window.processedNetwork;
            if (!network) {
                showNotification('Error', 'No network data loaded', 'error');
                return;
            }
            
            // Find LGX entry for this address
            const lgxEntry = network.lgx.find(e => 
                e.address && e.address.toLowerCase().includes(address.toLowerCase())
            );
            
            if (!lgxEntry) {
                showNotification('Not Found', 'Customer address not found in LGX panel', 'warning');
                return;
            }
            
            // Build trace path
            const path = [];
            path.push({
                type: 'customer',
                id: lgxEntry.address,
                details: lgxEntry
            });
            
            // Find MST
            const mst = network.msts.find(m => m.mst_id === lgxEntry.mst_hub);
            if (mst) {
                path.push({
                    type: 'mst',
                    id: mst.mst_id,
                    details: mst
                });
            }
            
            // Find passive cabinet for FDA
            if (mst && mst.fda) {
                const passiveCab = network.cabinets.find(c => 
                    c.type === 'PASSIVE' && c.fda === mst.fda
                );
                if (passiveCab) {
                    path.push({
                        type: 'cabinet',
                        subtype: 'passive',
                        id: passiveCab.cabinet_id,
                        details: passiveCab
                    });
                }
            }
            
            // Find active cabinet
            const activeCab = network.cabinets.find(c => c.type === 'ACTIVE');
            if (activeCab) {
                path.push({
                    type: 'cabinet',
                    subtype: 'active',
                    id: activeCab.cabinet_id,
                    details: activeCab
                });
            }
            
            // Show path trace
            showPathTrace(path);
            
            showNotification('Trace Complete', `Found path from ${address} to active cabinet`, 'success');
        }
        
        function showPathTrace(path) {
            const panel = document.getElementById('pathTracePanel');
            const content = document.getElementById('pathTraceContent');
            
            content.innerHTML = path.map((segment, index) => {
                let icon = '📍';
                let title = '';
                let details = '';
                
                switch (segment.type) {
                    case 'customer':
                        icon = '🏠';
                        title = 'Customer Location';
                        details = `
                            <div>Address: ${segment.details.address}</div>
                            <div>Port: ${segment.details.port} | Fiber: ${segment.details.fiber}</div>
                            ${segment.details.customer_id ? `<div>Customer ID: ${segment.details.customer_id}</div>` : ''}
                        `;
                        break;
                    case 'mst':
                        icon = '📟';
                        title = 'MST Hub';
                        details = `
                            <div>MST ID: ${segment.id}</div>
                            <div>Ports: ${segment.details.ports}</div>
                            <div>FDA: ${segment.details.fda}</div>
                        `;
                        break;
                    case 'cabinet':
                        icon = segment.subtype === 'active' ? '🔴' : '🟡';
                        title = `${segment.subtype === 'active' ? 'Active' : 'Passive'} Cabinet`;
                        details = `
                            <div>Cabinet ID: ${segment.id}</div>
                            <div>FSA: ${segment.details.fsa || 'N/A'}</div>
                            <div>FDA: ${segment.details.fda || 'N/A'}</div>
                        `;
                        break;
                }
                
                return `
                    <div class="path-segment">
                        <div class="path-segment-header">
                            <div class="path-segment-icon">${icon}</div>
                            <div>${title}</div>
                        </div>
                        <div style="margin-left: 2rem; font-size: 0.875rem; color: var(--text-light);">
                            ${details}
                        </div>
                    </div>
                `;
            }).join('');
            
            panel.classList.add('show');
        }
        
        function closePathTracePanel() {
            document.getElementById('pathTracePanel').classList.remove('show');
        }
        
        function setHierarchyView(view) {
            currentHierarchyView = view;
            
            // Update buttons
            document.querySelectorAll('.hierarchy-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // Filter display based on hierarchy
            // Implementation would filter network elements based on FSA/FDA
            showNotification('View Changed', `Showing ${view.toUpperCase()} hierarchy`, 'info');
        }
        
        function showLGXPanel() {
            const panel = document.getElementById('lgxPanelDisplay');
            const grid = document.getElementById('lgxPortGrid');
            
            // Generate LGX port visualization
            grid.innerHTML = '';
            
            const network = window.processedNetwork;
            if (!network || !network.lgx) return;
            
            // Create port grid (example: 144 ports)
            for (let i = 1; i <= 144; i++) {
                const lgxEntry = network.lgx.find(e => parseInt(e.port) === i);
                const assigned = lgxEntry && lgxEntry.customer_id;
                
                const portDiv = document.createElement('div');
                portDiv.className = `lgx-port ${assigned ? 'assigned' : 'unassigned'}`;
                portDiv.textContent = i;
                portDiv.title = lgxEntry ? 
                    `Port ${i}: ${lgxEntry.address || 'No address'} ${lgxEntry.customer_id ? '(Assigned)' : '(Unassigned)'}` : 
                    `Port ${i}: Available`;
                
                grid.appendChild(portDiv);
            }
            
            panel.classList.add('show');
        }
        
        function closeLGXPanel() {
            document.getElementById('lgxPanelDisplay').classList.remove('show');
        }
        
        function performNetworkSearch() {
            const query = document.getElementById('searchInput').value.toLowerCase();
            const results = document.getElementById('searchResults');
            
            if (!query) {
                results.innerHTML = '';
                return;
            }
            
            const network = window.processedNetwork;
            if (!network) return;
            
            const matches = [];
            
            // Search cables
            network.cables.forEach(cable => {
                if (cable.fondid.toLowerCase().includes(query)) {
                    matches.push({
                        type: 'cable',
                        item: cable,
                        title: cable.fondid,
                        details: `${cable.cable_type} - ${cable.size} fibers`
                    });
                }
            });
            
            // Search splices
            network.splices.forEach(splice => {
                if (splice.fondid.toLowerCase().includes(query)) {
                    matches.push({
                        type: 'splice',
                        item: splice,
                        title: splice.fondid,
                        details: `FDA: ${splice.fda} - ${splice.spec}`
                    });
                }
            });
            
            // Search cabinets
            network.cabinets.forEach(cabinet => {
                if (cabinet.cabinet_id.toLowerCase().includes(query)) {
                    matches.push({
                        type: 'cabinet',
                        item: cabinet,
                        title: cabinet.cabinet_id,
                        details: `${cabinet.type} - ${cabinet.fda}`
                    });
                }
            });
            
            // Search MSTs
            network.msts.forEach(mst => {
                if (mst.mst_id.toLowerCase().includes(query)) {
                    matches.push({
                        type: 'mst',
                        item: mst,
                        title: mst.mst_id,
                        details: `${mst.ports} ports - ${mst.fda}`
                    });
                }
            });
            
            // Search addresses
            network.lgx.forEach(entry => {
                if (entry.address && entry.address.toLowerCase().includes(query)) {
                    matches.push({
                        type: 'address',
                        item: entry,
                        title: entry.address,
                        details: `Port ${entry.port} - ${entry.mst_hub}`
                    });
                }
            });
            
            // Display results
            results.innerHTML = matches.slice(0, 10).map(match => `
                <div class="search-result" onclick="focusOnNetworkElement('${match.type}', '${match.title}')">
                    <div class="search-result-title">${match.title}</div>
                    <div class="search-result-details">${match.details}</div>
                </div>
            `).join('');
        }
        
        function focusOnNetworkElement(type, id) {
            let layer = null;
            
            if (type === 'cable' && networkLayers.cables[id]) {
                layer = networkLayers.cables[id];
                // Highlight cable
                layer.setStyle({ weight: 8, opacity: 1 });
                setTimeout(() => {
                    layer.setStyle({ weight: 4, opacity: 0.8 });
                }, 2000);
            } else if (type === 'splice') {
                // Find splice layer by fondid
                for (let key in networkLayers.splices) {
                    if (key === id) {
                        layer = networkLayers.splices[key];
                        break;
                    }
                }
            } else if (type === 'cabinet' && networkLayers.cabinets[id]) {
                layer = networkLayers.cabinets[id];
            } else if (type === 'mst' && networkLayers.msts[id]) {
                layer = networkLayers.msts[id];
            }
            
            if (layer) {
                if (layer.getLatLng) {
                    map.setView(layer.getLatLng(), 16);
                } else if (layer.getBounds) {
                    map.fitBounds(layer.getBounds());
                }
                
                // Open popup
                if (layer.openPopup) {
                    layer.openPopup();
                }
            }
            
            showNotification('Search', `Focused on ${type}: ${id}`, 'info');
        }
        
        // =====================================================================
        // SPLICE DOCUMENTATION GENERATION - Creating the Paperwork! 📄
        // =====================================================================
        function generateSpliceDocuments() {
            const container = document.getElementById('spliceMatrixContainer');
            container.innerHTML = '';
            
            const network = window.processedNetwork;
            if (!network || !network.connections) {
                container.innerHTML = '<p style="text-align: center; color: var(--text-light);">No splice data to display. Process network data first.</p>';
                return;
            }
            
            // Check for snapped connections first
            const snapConnections = window.cableSnapping.spliceConnections;
            
            if (Object.keys(snapConnections).length > 0) {
                // Generate sheets based on snapped connections
                let sheetNumber = 1;
                Object.keys(snapConnections).forEach(spliceId => {
                    const spliceData = snapConnections[spliceId];
                    if (spliceData.cables.length >= 2) {
                        const sheet = createSmartSpliceSheet(spliceData, sheetNumber);
                        container.appendChild(sheet);
                        sheetNumber++;
                    }
                });
            } else {
                // Fallback to original splice grouping
                const spliceGroups = groupConnectionsBySplice(network);
                
                let sheetNumber = 1;
                Object.keys(spliceGroups).sort().forEach(spliceKey => {
                    const group = spliceGroups[spliceKey];
                    const spliceSheet = createSpliceSheet(group, sheetNumber);
                    container.appendChild(spliceSheet);
                    sheetNumber++;
                });
            }
            
            // Add passive cabinet sheets
            const passiveCabinets = network.cabinets.filter(c => c.type === 'PASSIVE');
            passiveCabinets.forEach(cabinet => {
                const cabinetSheet = createPassiveCabinetSheet(cabinet, network);
                container.appendChild(cabinetSheet);
            });
        }
        
        function createSmartSpliceSheet(spliceData, sheetNumber) {
            const sheet = document.createElement('div');
            sheet.className = 'splice-sheet-preview';
            
            const splice = spliceData.splice;
            const cables = spliceData.cables;
            
            // Group cables by type for proper pairing
            const cablePairs = identifyCablePairs(cables);
            
            sheet.innerHTML = `
                <div class="sheet-header">
                    <div class="company-info">
                        <div class="company-logo">🔥 Phoenix Fiber</div>
                        <div class="document-info">
                            <div>Document: ${splice.fondid}</div>
                            <div>Date: ${new Date().toLocaleDateString()}</div>
                            <div>Generated by: Smart Snapping System</div>
                        </div>
                    </div>
                    <h2 class="sheet-title">Splice Matrix - ${splice.fondid}</h2>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Closure Information</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            <div>Closure Name: ${splice.fondid}</div>
                            <div>County: Augusta</div>
                            <div>FSA: ${splice.fsa || 'VA-AUGS-02'}</div>
                            <div>FDA: ${splice.fda || 'TBD'}</div>
                            <div>Placement: ${splice.placement || 'AERIAL'}</div>
                            <div>Spec: ${splice.spec || 'X-2'}</div>
                            <div>Connected Cables: ${cables.length}</div>
                        </div>
                    </div>
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Connected Cables</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            ${cables.map(c => `
                                <div>${c.cableId} (${c.cableType})</div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--surface-2); border-radius: var(--radius-sm);">
                    <span class="splice-status connected">Snapped Connection Verified</span>
                    <span style="margin-left: 1rem; font-size: 0.875rem; color: var(--text-light);">
                        This splice was automatically detected through cable-to-splice snapping
                    </span>
                </div>
                
                <table class="splice-matrix-table">
                    <thead>
                        <tr>
                            <th>Closure</th>
                            <th>Cable In</th>
                            <th>Fiber In</th>
                            <th>Type</th>
                            <th>Port</th>
                            <th>Tier</th>
                            <th>Fiber Out</th>
                            <th>Cable Out</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${generateSmartSpliceRows(splice.fondid, cablePairs)}
                    </tbody>
                </table>
            `;
            
            return sheet;
        }
        
        function generateSmartSpliceRows(spliceId, cablePairs) {
            let rows = '';
            
            cablePairs.forEach(pair => {
                const { cableIn, cableOut } = pair;
                
                // Use GEM parser to understand connections
                const inParsed = parseCableCt(cableIn.cable.cable_ct, cableIn.cableId);
                const outParsed = parseCableCt(cableOut.cable.cable_ct, cableOut.cableId);
                
                // Generate connection rows based on parsed data
                const connections = Math.min(inParsed.totalLitFibers, outParsed.totalLitFibers);
                
                for (let i = 0; i < connections; i++) {
                    rows += `
                        <tr>
                            <td>${spliceId}</td>
                            <td>${cableIn.cableId}</td>
                            <td>${i + 1}</td>
                            <td>SPLICE</td>
                            <td>${i + 1}</td>
                            <td>T2</td>
                            <td>${i + 1}</td>
                            <td>${cableOut.cableId}</td>
                        </tr>
                    `;
                }
            });
            
            return rows;
        }
        
        function groupConnectionsBySplice(network) {
            const spliceGroups = {};
            
            // First, try to match connections to actual splice points
            network.connections.forEach(conn => {
                // Find splice point that matches this connection
                let matchedSplice = null;
                let spliceKey = null;
                
                // Look for splice that matches the cables
                for (let splice of network.splices) {
                    // Check if splice fondid relates to either cable
                    if (splice.fondid && (
                        conn.cableIn.includes(splice.fondid) ||
                        conn.cableOut.includes(splice.fondid) ||
                        splice.fondid.includes(conn.cableIn) ||
                        splice.fondid.includes(conn.cableOut)
                    )) {
                        matchedSplice = splice;
                        spliceKey = splice.fondid;
                        break;
                    }
                }
                
                // If no splice found, generate key based on cable pair and FDA
                if (!spliceKey) {
                    // Try to determine FDA from cables
                    let fda = 'Unknown';
                    let fsa = 'Unknown';
                    
                    // Extract FDA from cable naming
                    const fdaMatch = (conn.cableIn + conn.cableOut).match(/FDA[_-]?(\d+)/i);
                    if (fdaMatch) {
                        const fdaNum = fdaMatch[1].padStart(3, '0');
                        fda = `VAAUGS0${fdaNum}`;
                        fsa = 'VA-AUGS-02'; // Default FSA
                    }
                    
                    // Generate splice name following convention
                    const fdaNumber = fda.replace(/[^\d]/g, '').replace(/^0+/, '');
                    spliceKey = `AUGS-2_FDA_${fdaNumber}_SP_AUTO`;
                }
                
                if (!spliceGroups[spliceKey]) {
                    spliceGroups[spliceKey] = {
                        spliceId: spliceKey,
                        splice: matchedSplice,
                        connections: [],
                        cables: new Set()
                    };
                }
                
                spliceGroups[spliceKey].connections.push(conn);
                spliceGroups[spliceKey].cables.add(conn.cableIn);
                spliceGroups[spliceKey].cables.add(conn.cableOut);
            });
            
            return spliceGroups;
        }
        
        function createSpliceSheet(spliceGroup, sheetNumber) {
            const sheet = document.createElement('div');
            sheet.className = 'splice-sheet-preview';
            
            // Get splice details
            const splice = spliceGroup.splice || {};
            const spliceId = spliceGroup.spliceId;
            
            // Extract FDA/FSA from splice or cables
            let fda = splice.fda || 'Unknown';
            let fsa = splice.fsa || 'VA-AUGS-02';
            
            if (fda === 'Unknown' && spliceId.includes('FDA_')) {
                const fdaMatch = spliceId.match(/FDA_(\d+)/);
                if (fdaMatch) {
                    fda = `VAAUGS0${fdaMatch[1].padStart(3, '0')}`;
                }
            }
            
            // Group connections by cable pair
            const cablePairs = {};
            spliceGroup.connections.forEach(conn => {
                const pairKey = `${conn.cableIn}_to_${conn.cableOut}`;
                if (!cablePairs[pairKey]) {
                    cablePairs[pairKey] = [];
                }
                cablePairs[pairKey].push(conn);
            });
            
            sheet.innerHTML = `
                <div class="sheet-header">
                    <div class="company-info">
                        <div class="company-logo">🔥 Phoenix Fiber</div>
                        <div class="document-info">
                            <div>Document: ${spliceId}</div>
                            <div>Date: ${new Date().toLocaleDateString()}</div>
                            <div>Generated by: GEM Fiber Logic</div>
                        </div>
                    </div>
                    <h2 class="sheet-title">Splice Matrix - ${spliceId}</h2>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Closure Information</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            <div>Closure Name: ${spliceId}</div>
                            <div>County: Augusta</div>
                            <div>FSA: ${fsa}</div>
                            <div>FDA: ${fda}</div>
                            <div>Placement: ${splice.placement || 'AERIAL'}</div>
                            <div>Spec: ${splice.spec || 'X-2'}</div>
                            <div>Total Fiber Burns: ${spliceGroup.connections.length}</div>
                        </div>
                    </div>
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Connected Cables</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            ${Array.from(spliceGroup.cables).map(cableId => {
                                const cable = window.processedNetwork.cables.find(c => c.fondid === cableId);
                                return `<div>${cableId} (${cable?.cable_type || 'Unknown'} - ${cable?.size || '?'} fibers)</div>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
                
                ${Object.keys(cablePairs).map(pairKey => {
                    const connections = cablePairs[pairKey];
                    const [cableInId, cableOutId] = pairKey.split('_to_');
                    
                    return `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--secondary);">
                                ${cableInId} → ${cableOutId}
                            </h4>
                            <table class="splice-matrix-table">
                                <thead>
                                    <tr>
                                        <th>Closure</th>
                                        <th>Cable In</th>
                                        <th>Ribbon In</th>
                                        <th>Fiber In</th>
                                        <th>Type</th>
                                        <th>Port</th>
                                        <th>Tier</th>
                                        <th>Fiber Out</th>
                                        <th>Ribbon Out</th>
                                        <th>Cable Out</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${connections.map(conn => {
                                        const ribbonIn = getRibbonColor(conn.fiberIn);
                                        const ribbonOut = getRibbonColor(conn.fiberOut);
                                        return `
                                            <tr>
                                                <td>${spliceId}</td>
                                                <td>${conn.cableIn}</td>
                                                <td>${ribbonIn}</td>
                                                <td>${conn.fiberIn}</td>
                                                <td>SPLICE</td>
                                                <td>${conn.port}</td>
                                                <td>${conn.tier}</td>
                                                <td>${conn.fiberOut}</td>
                                                <td>${ribbonOut}</td>
                                                <td>${conn.cableOut}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                    `;
                }).join('')}
                
                <div style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                    <h4 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Fiber Color Code Reference</h4>
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem; font-size: 0.75rem;">
                        ${['Blue', 'Orange', 'Green', 'Brown', 'Slate', 'White', 'Red', 'Black', 'Yellow', 'Violet', 'Rose', 'Aqua'].map((color, idx) => 
                            `<div>${idx + 1}: ${color}</div>`
                        ).join('')}
                    </div>
                </div>
            `;
            
            return sheet;
        }
        
        function createPassiveCabinetSheet(cabinet, network) {
            const sheet = document.createElement('div');
            sheet.className = 'splice-sheet-preview';
            
            // Find all connections through this cabinet
            const cabinetConnections = network.connections.filter(conn => {
                // Check if connection involves cabinet's cables
                const cableIn = network.cables.find(c => c.fondid === conn.cableIn);
                const cableOut = network.cables.find(c => c.fondid === conn.cableOut);
                
                return (cableIn && cableIn.cable_ct && cableIn.cable_ct.includes(cabinet.cabinet_id)) ||
                       (cableOut && cableOut.cable_ct && cableOut.cable_ct.includes(cabinet.cabinet_id));
            });
            
            sheet.innerHTML = `
                <div class="sheet-header">
                    <div class="company-info">
                        <div class="company-logo">🔥 Phoenix Fiber</div>
                        <div class="document-info">
                            <div>Document: ${cabinet.cabinet_id}</div>
                            <div>Date: ${new Date().toLocaleDateString()}</div>
                            <div>Type: Passive Cabinet</div>
                        </div>
                    </div>
                    <h2 class="sheet-title">Passive Cabinet - ${cabinet.cabinet_id}</h2>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Cabinet Information</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            <div>Cabinet ID: ${cabinet.cabinet_id}</div>
                            <div>Type: ${cabinet.type}</div>
                            <div>Size: ${cabinet.cab_size || '288'} ports</div>
                            <div>FSA: ${cabinet.fsa}</div>
                            <div>FDA: ${cabinet.fda}</div>
                            <div>Spec: ${cabinet.spec || 'N/A'}</div>
                        </div>
                    </div>
                    <div>
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Connection Summary</h3>
                        <div style="font-size: 0.875rem; color: var(--text-light);">
                            <div>Total Connections: ${cabinetConnections.length}</div>
                            <div>Feeder Cables: ${network.cables.filter(c => c.cable_type === 'FEEDER' && c.cable_ct?.includes(cabinet.cabinet_id)).length}</div>
                            <div>Distribution Cables: ${network.cables.filter(c => c.cable_type === 'DISTRIBUTION' && c.cable_ct?.includes(cabinet.cabinet_id)).length}</div>
                        </div>
                    </div>
                </div>
                
                ${cabinetConnections.length > 0 ? `
                    <table class="splice-matrix-table">
                        <thead>
                            <tr>
                                <th>Cabinet</th>
                                <th>Cable In</th>
                                <th>Fiber In</th>
                                <th>Port</th>
                                <th>Tier</th>
                                <th>Fiber Out</th>
                                <th>Cable Out</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${cabinetConnections.map(conn => `
                                <tr>
                                    <td>${cabinet.cabinet_id}</td>
                                    <td>${conn.cableIn}</td>
                                    <td>${conn.fiberIn}</td>
                                    <td>${conn.port}</td>
                                    <td>${conn.tier}</td>
                                    <td>${conn.fiberOut}</td>
                                    <td>${conn.cableOut}</td>
                                    <td><span style="color: var(--success);">Connected</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                ` : '<p style="text-align: center; color: var(--text-light);">No connections found for this cabinet</p>'}
            `;
            
            return sheet;
        }
        
        function getRibbonColor(fiberNumber) {
            const colorIndex = (Math.floor((fiberNumber - 1) / 12)) % 12;
            const colors = ['Blue', 'Orange', 'Green', 'Brown', 'Slate', 'White', 
                          'Red', 'Black', 'Yellow', 'Violet', 'Rose', 'Aqua'];
            return colors[colorIndex];
        }
        
        function getFiberColorName(fiberNumber) {
            const colors = [
                'Blue', 'Orange', 'Green', 'Brown', 'Slate', 'White',
                'Red', 'Black', 'Yellow', 'Violet', 'Rose', 'Aqua'
            ];
            const position = ((fiberNumber - 1) % 12);
            return colors[position];
        }
        
        // =====================================================================
        // EXPORT FUNCTIONS - Getting Data Out! 📤
        // =====================================================================
        function exportSpliceExcel() {
            const network = window.processedNetwork;
            if (!network) {
                showNotification('Error', 'No network data to export', 'error');
                return;
            }
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Add LGX sheet
            const lgxData = [
                ['FIBERS', 'PORTS', 'MST HUB', 'ADDRESSES', 'CUSTOMER ID']
            ];
            
            network.lgx.forEach(entry => {
                lgxData.push([
                    entry.fiber,
                    entry.port,
                    entry.mst_hub,
                    entry.address || '',
                    entry.customer_id || ''
                ]);
            });
            
            const lgxSheet = XLSX.utils.aoa_to_sheet(lgxData);
            XLSX.utils.book_append_sheet(wb, lgxSheet, 'LGX');
            
            // Check for snapped connections first
            const snapConnections = window.cableSnapping.spliceConnections;
            
            if (Object.keys(snapConnections).length > 0) {
                // Export based on snapped connections
                let sheetIndex = 1;
                Object.keys(snapConnections).forEach(spliceId => {
                    const spliceData = snapConnections[spliceId];
                    if (spliceData.cables.length >= 2) {
                        const sheetName = `SP_${sheetIndex}`;
                        const spliceSheetData = createExcelSpliceSheet(spliceData);
                        const spliceSheet = XLSX.utils.aoa_to_sheet(spliceSheetData);
                        XLSX.utils.book_append_sheet(wb, spliceSheet, sheetName);
                        sheetIndex++;
                    }
                });
            } else {
                // Fallback to connection-based export
                const spliceGroups = {};
                network.connections.forEach(conn => {
                    const key = `${conn.cableIn}_to_${conn.cableOut}`;
                    if (!spliceGroups[key]) {
                        spliceGroups[key] = {
                            cableIn: conn.cableIn,
                            cableOut: conn.cableOut,
                            connections: []
                        };
                    }
                    spliceGroups[key].connections.push(conn);
                });
                
                // Add splice sheets
                Object.keys(spliceGroups).forEach((key, index) => {
                    const group = spliceGroups[key];
                    const sheetName = `SP_${index + 1}`;
                    
                    // Create header rows
                    const spliceData = [
                        ['Closure Name:', sheetName],
                        ['County', 'Augusta'],
                        ['FSA', 'AUGS-2'],
                        ['FDA', '2.04'],
                        ['Cable In:', group.cableIn],
                        ['Cable Out:', group.cableOut],
                        [],
                        ['Closure', 'Cable In', 'Fiber In', 'Color', 'Type', 'Port', 'Fiber Out', 'Color', 'Cable Out']
                    ];
                    
                    // Add connection data
                    group.connections.forEach(conn => {
                        spliceData.push([
                            sheetName,
                            conn.cableIn,
                            conn.fiberIn,
                            getFiberColorName(conn.fiberIn),
                            'SPLICE',
                            conn.port,
                            conn.fiberOut,
                            getFiberColorName(conn.fiberOut),
                            conn.cableOut
                        ]);
                    });
                    
                    const spliceSheet = XLSX.utils.aoa_to_sheet(spliceData);
                    XLSX.utils.book_append_sheet(wb, spliceSheet, sheetName);
                });
            }
            
            // Add light trace sheet
            const traceData = [
                ['Light Trace Path Analysis'],
                ['Generated:', new Date().toLocaleString()],
                [],
                ['From', 'To', 'Connection Type', 'Details']
            ];
            
            // Add trace data
            if (network.lightSource) {
                traceData.push(['Light Source', network.lightSource, 'Origin', `${network.cables.find(c => c.fondid === network.lightSource)?.size || 'N/A'} fibers`]);
            }
            
            const traceSheet = XLSX.utils.aoa_to_sheet(traceData);
            XLSX.utils.book_append_sheet(wb, traceSheet, 'Light_Trace');
            
            // Export workbook
            XLSX.writeFile(wb, `Phoenix_Fiber_Splicing_${new Date().toISOString().split('T')[0]}.xlsx`);
            
            showNotification('Export Complete', 'Splicing documentation exported to Excel', 'success');
        }
        
        function createExcelSpliceSheet(spliceData) {
            const splice = spliceData.splice;
            const cables = spliceData.cables;
            const cablePairs = identifyCablePairs(cables);
            
            const data = [
                ['Closure Name:', splice.fondid],
                ['County:', 'Augusta'],
                ['FSA:', splice.fsa || 'VA-AUGS-02'],
                ['FDA:', splice.fda || 'TBD'],
                ['Placement:', splice.placement || 'AERIAL'],
                ['Spec:', splice.spec || 'X-2'],
                ['Connected Cables:', cables.length],
                [],
                ['Status:', 'Snapped Connection Verified'],
                [],
                ['Closure', 'Cable In', 'Fiber In', 'Type', 'Port', 'Tier', 'Fiber Out', 'Cable Out']
            ];
            
            // Add connection rows
            cablePairs.forEach(pair => {
                const { cableIn, cableOut } = pair;
                const inParsed = parseCableCt(cableIn.cable.cable_ct, cableIn.cableId);
                const outParsed = parseCableCt(cableOut.cable.cable_ct, cableOut.cableId);
                const connections = Math.min(inParsed.totalLitFibers, outParsed.totalLitFibers);
                
                for (let i = 0; i < connections; i++) {
                    data.push([
                        splice.fondid,
                        cableIn.cableId,
                        i + 1,
                        'SPLICE',
                        i + 1,
                        'T2',
                        i + 1,
                        cableOut.cableId
                    ]);
                }
            });
            
            return data;
        }
        
        function generatePDF() {
            showNotification('Coming Soon', 'PDF generation will be available in the next update', 'info');
        }
        
        function printSpliceSheets() {
            window.print();
        }
        
        function validateNetwork() {
            const network = window.processedNetwork;
            if (!network) {
                showNotification('No Data', 'Please process network data first', 'warning');
                return;
            }
            
            const issues = [];
            const warnings = [];
            
            // Check for unconnected cables
            const connectedCables = new Set();
            network.connections.forEach(conn => {
                connectedCables.add(conn.cableIn);
                connectedCables.add(conn.cableOut);
            });
            
            network.cables.forEach(cable => {
                if (!connectedCables.has(cable.fondid) && cable.fondid !== network.lightSource) {
                    warnings.push(`Cable ${cable.fondid} has no connections`);
                }
            });
            
            // Validate fiber continuity
            const fiberMap = {};
            network.connections.forEach(conn => {
                // Check if fiber numbers match (1-to-1 mapping)
                if (conn.fiberIn !== conn.fiberOut) {
                    warnings.push(`Fiber mismatch at port ${conn.port}: ${conn.cableIn}[${conn.fiberIn}] → ${conn.cableOut}[${conn.fiberOut}]`);
                }
                
                // Track fiber usage
                const keyIn = `${conn.cableIn}_${conn.fiberIn}`;
                const keyOut = `${conn.cableOut}_${conn.fiberOut}`;
                
                if (fiberMap[keyIn]) {
                    issues.push(`Duplicate connection on ${conn.cableIn} fiber ${conn.fiberIn}`);
                }
                if (fiberMap[keyOut]) {
                    issues.push(`Duplicate connection on ${conn.cableOut} fiber ${conn.fiberOut}`);
                }
                
                fiberMap[keyIn] = true;
                fiberMap[keyOut] = true;
            });
            
            // Check tier assignments
            network.connections.forEach(conn => {
                const cableIn = network.cables.find(c => c.fondid === conn.cableIn);
                const cableOut = network.cables.find(c => c.fondid === conn.cableOut);
                
                if (cableIn && cableOut) {
                    // Validate tier progression
                    if (conn.tier === 'T3' && cableIn.cable_type !== 'FEEDER') {
                        warnings.push(`T3 connection on non-feeder cable: ${cableIn.fondid}`);
                    }
                    if (conn.tier === 'T2' && cableIn.cable_type !== 'DISTRIBUTION') {
                        warnings.push(`T2 connection on non-distribution cable: ${cableIn.fondid}`);
                    }
                }
            });
            
            // Check MST port allocation
            const mstPortUsage = {};
            network.lgx.forEach(entry => {
                if (!mstPortUsage[entry.mst_hub]) {
                    mstPortUsage[entry.mst_hub] = new Set();
                }
                
                if (mstPortUsage[entry.mst_hub].has(entry.port)) {
                    issues.push(`Duplicate port assignment on ${entry.mst_hub} port ${entry.port}`);
                }
                mstPortUsage[entry.mst_hub].add(entry.port);
            });
            
            // Verify MST capacity
            network.msts.forEach(mst => {
                const usedPorts = mstPortUsage[mst.mst_id] ? mstPortUsage[mst.mst_id].size : 0;
                const capacity = parseInt(mst.ports);
                
                if (usedPorts > capacity) {
                    issues.push(`MST ${mst.mst_id} over capacity: ${usedPorts}/${capacity} ports used`);
                }
            });
            
            // Check for parsing errors
            if (parsingErrors.length > 0) {
                parsingErrors.forEach(error => {
                    issues.push(`Parsing error in ${error.cableId}: ${error.errors}`);
                });
            }
            
            // Validate snapped connections
            const snapIssues = window.cableSnapping.validateSpliceConnections();
            snapIssues.forEach(issue => {
                if (issue.type === 'warning') {
                    warnings.push(issue.message);
                } else {
                    issues.push(issue.message);
                }
            });
            
            // Display validation results
            const totalIssues = issues.length + warnings.length;
            
            if (totalIssues === 0) {
                showNotification('Validation Passed', 'Network configuration is valid ✅', 'success');
            } else {
                console.log('Validation Issues:', issues);
                console.log('Validation Warnings:', warnings);
                
                let message = '';
                if (issues.length > 0) {
                    message = `${issues.length} critical issues found`;
                }
                if (warnings.length > 0) {
                    message += (message ? ', ' : '') + `${warnings.length} warnings`;
                }
                
                showNotification('Validation Results', message + '. Check console for details.', 
                    issues.length > 0 ? 'error' : 'warning');
            }
            
            return { issues, warnings };
        }
        
        function exportKML() {
            const network = window.processedNetwork;
            if (!network) {
                showNotification('No Data', 'Please process network data first', 'warning');
                return;
            }
            
            let kml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            kml += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
            kml += '<Document>\n';
            kml += '<name>Phoenix Fiber Network</name>\n';
            
            // Add styles
            kml += '<Style id="feederStyle"><LineStyle><color>ff0080ff</color><width>4</width></LineStyle></Style>\n';
            kml += '<Style id="distributionStyle"><LineStyle><color>ff00ff00</color><width>3</width></LineStyle></Style>\n';
            kml += '<Style id="tailStyle"><LineStyle><color>ffff00ff</color><width>2</width></LineStyle></Style>\n';
            
            // Add cables
            network.cables.forEach(cable => {
                if (cable.wkt_geom) {
                    const coords = parseLineStringForKML(cable.wkt_geom);
                    if (coords) {
                        kml += '<Placemark>\n';
                        kml += `<name>${cable.fondid}</name>\n`;
                        kml += `<description>Type: ${cable.cable_type}, Size: ${cable.size}</description>\n`;
                        kml += `<styleUrl>#${cable.cable_type.toLowerCase().replace(' ', '')}Style</styleUrl>\n`;
                        kml += '<LineString>\n';
                        kml += `<coordinates>${coords}</coordinates>\n`;
                        kml += '</LineString>\n';
                        kml += '</Placemark>\n';
                    }
                }
            });
            
            kml += '</Document>\n</kml>';
            
            // Download KML
            const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Phoenix_Fiber_Network_${new Date().toISOString().split('T')[0]}.kml`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Export Complete', 'Network exported to KML', 'success');
        }
        
        function parseLineStringForKML(wkt) {
            if (wkt.includes('MULTILINESTRING')) {
                // Extract first linestring from MultiLineString
                const match = wkt.match(/MULTILINESTRING\s*\(\s*\(\s*(.+?)\s*\)/);
                if (match) {
                    return convertCoordsToKML(match[1]);
                }
            } else if (wkt.includes('LINESTRING')) {
                const match = wkt.match(/LINESTRING\s*\(\s*(.+)\s*\)/);
                if (match) {
                    return convertCoordsToKML(match[1]);
                }
            }
            return null;
        }
        
        function convertCoordsToKML(coordString) {
            const pairs = coordString.split(',');
            return pairs.map(pair => {
                const [lng, lat] = pair.trim().split(' ');
                return `${lng},${lat},0`;
            }).join(' ');
        }
        
        function importLGXFromExcel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx,.xls';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Find LGX sheet
                        const lgxSheetName = workbook.SheetNames.find(name => 
                            name.toUpperCase().includes('LGX')
                        );
                        
                        if (!lgxSheetName) {
                            showNotification('Error', 'No LGX sheet found in Excel file', 'error');
                            return;
                        }
                        
                        const sheet = workbook.Sheets[lgxSheetName];
                        const jsonData = XLSX.utils.sheet_to_json(sheet);
                        
                        // Clear existing LGX data
                        clearLGXGrid();
                        
                        // Import data
                        jsonData.forEach((row, index) => {
                            if (index === 0) return; // Skip header if present
                            
                            addLGXRows(1);
                            const gridRow = document.getElementById('lgxGridBody').lastElementChild;
                            
                            // Map Excel columns to grid fields
                            if (row['FIBERS'] !== undefined) gridRow.querySelector('[data-field="fiber"]').value = row['FIBERS'];
                            if (row['PORTS'] !== undefined) gridRow.querySelector('[data-field="port"]').value = row['PORTS'];
                            if (row['MST HUB'] !== undefined) gridRow.querySelector('[data-field="mst_hub"]').value = row['MST HUB'];
                            if (row['ADDRESSES'] !== undefined) gridRow.querySelector('[data-field="address"]').value = row['ADDRESSES'];
                            if (row['CUSTOMER ID'] !== undefined) gridRow.querySelector('[data-field="customer_id"]').value = row['CUSTOMER ID'];
                        });
                        
                        showNotification('Import Success', `Imported ${jsonData.length} LGX entries`, 'success');
                    } catch (error) {
                        console.error('Import error:', error);
                        showNotification('Import Failed', 'Error reading Excel file', 'error');
                    }
                };
                
                reader.readAsArrayBuffer(file);
            };
            
            input.click();
        }
        
        // =====================================================================
        // UTILIZATION DASHBOARD - Network Analytics! 📊
        // =====================================================================
        function generateUtilizationDashboard() {
            const network = window.processedNetwork;
            if (!network) {
                document.getElementById('utilizationDashboard').style.display = 'none';
                document.getElementById('noDataMessage').style.display = 'block';
                return;
            }
            
            document.getElementById('utilizationDashboard').style.display = 'block';
            document.getElementById('noDataMessage').style.display = 'none';
            
            // Calculate utilization metrics
            const metrics = calculateUtilizationMetrics(network);
            
            // Update network summary
            const summaryHtml = `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                    <span>Total Fiber Count:</span>
                    <strong>${metrics.totalFibers}</strong>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                    <span>Lit Fibers:</span>
                    <strong style="color: var(--success);">${metrics.litFibers}</strong>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                    <span>Dark Fibers:</span>
                    <strong style="color: var(--text-light);">${metrics.darkFibers}</strong>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-top: 1px solid var(--border); margin-top: 0.5rem; padding-top: 1rem;">
                    <span>Overall Utilization:</span>
                    <strong style="color: var(--primary);">${metrics.utilizationPercent.toFixed(1)}%</strong>
                </div>
            `;
            document.getElementById('networkSummary').innerHTML = summaryHtml;
            
            // Update fiber type utilization
            const typeHtml = Object.keys(metrics.byType).map(type => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                    <span>${type}:</span>
                    <div>
                        <strong>${metrics.byType[type].lit}/${metrics.byType[type].total}</strong>
                        <span style="color: var(--text-light); margin-left: 0.5rem;">
                            (${((metrics.byType[type].lit / metrics.byType[type].total) * 100).toFixed(1)}%)
                        </span>
                    </div>
                </div>
            `).join('');
            document.getElementById('fiberTypeUtilization').innerHTML = typeHtml;
            
            // Build FDA utilization table
            const fdaTable = buildFDAUtilizationTable(metrics.byFDA);
            document.getElementById('fdaUtilization').innerHTML = fdaTable;
            
            // Build cable detail table
            const cableTable = buildCableUtilizationTable(network, metrics.byCable);
            document.getElementById('cableUtilizationTable').innerHTML = cableTable;
            
            // Populate FDA filter
            const fdaFilter = document.getElementById('fdaFilter');
            fdaFilter.innerHTML = '<option value="">All FDAs</option>';
            Object.keys(metrics.byFDA).forEach(fda => {
                fdaFilter.innerHTML += `<option value="${fda}">${fda}</option>`;
            });
        }
        
        function calculateUtilizationMetrics(network) {
            const metrics = {
                totalFibers: 0,
                litFibers: 0,
                darkFibers: 0,
                utilizationPercent: 0,
                byType: {},
                byFDA: {},
                byCable: {}
            };
            
            // Process each cable
            network.cables.forEach(cable => {
                const cableSize = parseInt(cable.size) || 0;
                metrics.totalFibers += cableSize;
                
                // Parse cable_ct to determine lit/dark fibers
                let litCount = 0;
                let darkCount = 0;
                
                if (cable.cable_ct) {
                    const parsed = parseCableCt(cable.cable_ct, cable.fondid);
                    
                    parsed.fiberRanges.forEach(range => {
                        const count = range.endFiber - range.startFiber + 1;
                        if (range.isDeadFiber) {
                            darkCount += count;
                        } else {
                            litCount += count;
                        }
                    });
                } else {
                    // If no cable_ct, assume all dark
                    darkCount = cableSize;
                }
                
                metrics.litFibers += litCount;
                metrics.darkFibers += darkCount;
                
                // Store cable metrics
                metrics.byCable[cable.fondid] = {
                    type: cable.cable_type,
                    size: cableSize,
                    lit: litCount,
                    dark: darkCount,
                    utilization: cableSize > 0 ? (litCount / cableSize) * 100 : 0
                };
                
                // Aggregate by type
                if (!metrics.byType[cable.cable_type]) {
                    metrics.byType[cable.cable_type] = { total: 0, lit: 0, dark: 0 };
                }
                metrics.byType[cable.cable_type].total += cableSize;
                metrics.byType[cable.cable_type].lit += litCount;
                metrics.byType[cable.cable_type].dark += darkCount;
                
                // Determine FDA from cable naming or connections
                let fda = 'Unknown';
                
                // Try to extract FDA from cable fondid
                const fdaMatch = cable.fondid.match(/FDA[_-]?(\d+)/i);
                if (fdaMatch) {
                    fda = `VAAUGS0${fdaMatch[1].padStart(3, '0')}`;
                } else {
                    // Look for connected splice/cabinet FDA
                    const connectedSplice = network.splices.find(s => 
                        cable.fondid.includes(s.fondid) || s.fondid.includes(cable.fondid)
                    );
                    if (connectedSplice && connectedSplice.fda) {
                        fda = connectedSplice.fda;
                    }
                }
                
                // Aggregate by FDA
                if (!metrics.byFDA[fda]) {
                    metrics.byFDA[fda] = { total: 0, lit: 0, dark: 0, cables: [] };
                }
                metrics.byFDA[fda].total += cableSize;
                metrics.byFDA[fda].lit += litCount;
                metrics.byFDA[fda].dark += darkCount;
                metrics.byFDA[fda].cables.push(cable.fondid);
            });
            
            // Calculate overall utilization
            if (metrics.totalFibers > 0) {
                metrics.utilizationPercent = (metrics.litFibers / metrics.totalFibers) * 100;
            }
            
            return metrics;
        }
        
        function buildFDAUtilizationTable(fdaData) {
            let html = `
                <table class="data-grid" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>FDA</th>
                            <th>Total Fibers</th>
                            <th>Lit</th>
                            <th>Dark</th>
                            <th>Utilization</th>
                            <th>Cable Count</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            Object.keys(fdaData).sort().forEach(fda => {
                const data = fdaData[fda];
                const utilization = data.total > 0 ? (data.lit / data.total) * 100 : 0;
                
                html += `
                    <tr>
                        <td style="padding: 0.5rem; font-weight: 600;">${fda}</td>
                        <td style="padding: 0.5rem; text-align: center;">${data.total}</td>
                        <td style="padding: 0.5rem; text-align: center; color: var(--success);">${data.lit}</td>
                        <td style="padding: 0.5rem; text-align: center; color: var(--text-light);">${data.dark}</td>
                        <td style="padding: 0.5rem; text-align: center;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div style="flex: 1; height: 8px; background: var(--surface-3); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${utilization}%; height: 100%; background: var(--primary);"></div>
                                </div>
                                <span style="font-weight: 600; min-width: 45px;">${utilization.toFixed(1)}%</span>
                            </div>
                        </td>
                        <td style="padding: 0.5rem; text-align: center;">${data.cables.length}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        function buildCableUtilizationTable(network, cableMetrics) {
            let html = `
                <table class="data-grid" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Cable ID</th>
                            <th>Type</th>
                            <th>Size</th>
                            <th>Lit</th>
                            <th>Dark</th>
                            <th>Utilization</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="cableTableBody">
            `;
            
            Object.keys(cableMetrics).forEach(cableId => {
                const data = cableMetrics[cableId];
                const isLightSource = cableId === network.lightSource;
                
                html += `
                    <tr class="cable-row" data-cable="${cableId}">
                        <td style="padding: 0.5rem; font-weight: 600;">
                            ${cableId}
                            ${isLightSource ? '<span style="color: var(--warning); margin-left: 0.5rem;">⚡</span>' : ''}
                        </td>
                        <td style="padding: 0.5rem;">${data.type}</td>
                        <td style="padding: 0.5rem; text-align: center;">${data.size}</td>
                        <td style="padding: 0.5rem; text-align: center; color: var(--success);">${data.lit}</td>
                        <td style="padding: 0.5rem; text-align: center; color: var(--text-light);">${data.dark}</td>
                        <td style="padding: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div style="flex: 1; height: 8px; background: var(--surface-3); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${data.utilization}%; height: 100%; background: ${getUtilizationColor(data.utilization)};"></div>
                                </div>
                                <span style="font-weight: 600; min-width: 45px;">${data.utilization.toFixed(1)}%</span>
                            </div>
                        </td>
                        <td style="padding: 0.5rem; text-align: center;">
                            ${getUtilizationStatus(data.utilization)}
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        function getUtilizationColor(percent) {
            if (percent >= 80) return '#ef4444';  // Red - High
            if (percent >= 50) return '#f59e0b';  // Orange - Medium
            return '#10b981';  // Green - Low
        }
        
        function getUtilizationStatus(percent) {
            if (percent >= 80) {
                return '<span style="color: var(--error); font-weight: 600;">High</span>';
            }
            if (percent >= 50) {
                return '<span style="color: var(--warning); font-weight: 600;">Medium</span>';
            }
            return '<span style="color: var(--success); font-weight: 600;">Low</span>';
        }
        
        function filterUtilizationTable() {
            const filterValue = document.getElementById('fdaFilter').value;
            const rows = document.querySelectorAll('#cableTableBody .cable-row');
            const network = window.processedNetwork;
            
            if (!network || !filterValue) {
                // Show all rows if no filter
                rows.forEach(row => {
                    row.style.display = '';
                });
                return;
            }
            
            // Filter rows based on FDA
            rows.forEach(row => {
                const cableId = row.getAttribute('data-cable');
                const cable = network.cables.find(c => c.fondid === cableId);
                
                if (!cable) {
                    row.style.display = 'none';
                    return;
                }
                
                // Determine cable's FDA
                let cableFDA = 'Unknown';
                
                // Try to extract from cable ID
                const fdaMatch = cable.fondid.match(/FDA[_-]?(\d+)/i);
                if (fdaMatch) {
                    cableFDA = `VAAUGS0${fdaMatch[1].padStart(3, '0')}`;
                } else {
                    // Look for connected splice/cabinet FDA
                    const connectedSplice = network.splices.find(s => 
                        cable.fondid.includes(s.fondid) || s.fondid.includes(cable.fondid)
                    );
                    if (connectedSplice && connectedSplice.fda) {
                        cableFDA = connectedSplice.fda;
                    } else {
                        // Check if cable connects to a cabinet
                        const connectedCabinet = network.cabinets.find(c => 
                            cable.cable_ct && cable.cable_ct.includes(c.cabinet_id)
                        );
                        if (connectedCabinet && connectedCabinet.fda) {
                            cableFDA = connectedCabinet.fda;
                        }
                    }
                }
                
                // Show/hide based on filter
                row.style.display = (cableFDA === filterValue) ? '' : 'none';
            });
            
            // Update summary stats for filtered view
            updateFilteredStats(filterValue);
        }
        
        function updateFilteredStats(fda) {
            const network = window.processedNetwork;
            if (!network) return;
            
            const metrics = calculateUtilizationMetrics(network);
            
            if (fda && metrics.byFDA[fda]) {
                const fdaData = metrics.byFDA[fda];
                const utilization = fdaData.total > 0 ? (fdaData.lit / fdaData.total) * 100 : 0;
                
                // Update summary with filtered data
                const summaryHtml = `
                    <div style="background: var(--surface-2); padding: 0.75rem; border-radius: var(--radius-sm); margin-bottom: 0.75rem;">
                        <strong>Filtered by FDA: ${fda}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span>FDA Total Fibers:</span>
                        <strong>${fdaData.total}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span>FDA Lit Fibers:</span>
                        <strong style="color: var(--success);">${fdaData.lit}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span>FDA Dark Fibers:</span>
                        <strong style="color: var(--text-light);">${fdaData.dark}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-top: 1px solid var(--border); margin-top: 0.5rem; padding-top: 1rem;">
                        <span>FDA Utilization:</span>
                        <strong style="color: var(--primary);">${utilization.toFixed(1)}%</strong>
                    </div>
                `;
                document.getElementById('networkSummary').innerHTML = summaryHtml;
            } else {
                // Reset to overall stats
                generateUtilizationDashboard();
            }
        }
        
        function exportNetworkData() {
            const network = window.processedNetwork;
            if (!network) {
                showNotification('No Data', 'Please process network data first', 'warning');
                return;
            }
            
            // Create comprehensive Excel workbook
            const wb = XLSX.utils.book_new();
            
            // Add network overview sheet
            const overviewData = [
                ['Phoenix Fiber Network Export'],
                ['Generated:', new Date().toLocaleString()],
                [''],
                ['Network Summary'],
                ['Total Cables:', network.cables.length],
                ['Total Splices:', network.splices.length],
                ['Total Cabinets:', network.cabinets.length],
                ['Total MSTs:', network.msts.length],
                ['Total Service Locations:', new Set(network.lgx.map(e => e.address).filter(a => a)).size],
                ['Light Source Cable:', network.lightSource || 'Not identified']
            ];
            
            const overviewSheet = XLSX.utils.aoa_to_sheet(overviewData);
            XLSX.utils.book_append_sheet(wb, overviewSheet, 'Overview');
            
            // Add cables sheet
            if (network.cables.length > 0) {
                const cableHeaders = ['cable_type', 'fondid', 'size', 'cable_ct', 'wkt_geom'];
                const cableData = [cableHeaders];
                network.cables.forEach(cable => {
                    cableData.push(cableHeaders.map(h => cable[h] || ''));
                });
                const cableSheet = XLSX.utils.aoa_to_sheet(cableData);
                XLSX.utils.book_append_sheet(wb, cableSheet, 'Cables');
            }
            
            // Add splices sheet
            if (network.splices.length > 0) {
                const spliceHeaders = ['fondid', 'fda', 'fsa', 'placement', 'spec', 'ap_type', 'wkt_geom'];
                const spliceData = [spliceHeaders];
                network.splices.forEach(splice => {
                    spliceData.push(spliceHeaders.map(h => splice[h] || ''));
                });
                const spliceSheet = XLSX.utils.aoa_to_sheet(spliceData);
                XLSX.utils.book_append_sheet(wb, spliceSheet, 'Splices');
            }
            
            // Add cabinets sheet
            if (network.cabinets.length > 0) {
                const cabinetHeaders = ['cabinet_id', 'type', 'cab_size', 'fsa', 'fda', 'spec', 'wkt_geom'];
                const cabinetData = [cabinetHeaders];
                network.cabinets.forEach(cabinet => {
                    cabinetData.push(cabinetHeaders.map(h => cabinet[h] || ''));
                });
                const cabinetSheet = XLSX.utils.aoa_to_sheet(cabinetData);
                XLSX.utils.book_append_sheet(wb, cabinetSheet, 'Cabinets');
            }
            
            // Add MSTs sheet
            if (network.msts.length > 0) {
                const mstHeaders = ['mst_id', 'ports', 'fda', 'fsa', 'spec', 'wkt_geom'];
                const mstData = [mstHeaders];
                network.msts.forEach(mst => {
                    mstData.push(mstHeaders.map(h => mst[h] || ''));
                });
                const mstSheet = XLSX.utils.aoa_to_sheet(mstData);
                XLSX.utils.book_append_sheet(wb, mstSheet, 'MSTs');
            }
            
            // Add LGX sheet
            if (network.lgx.length > 0) {
                const lgxHeaders = ['fiber', 'port', 'mst_hub', 'address', 'customer_id'];
                const lgxData = [lgxHeaders];
                network.lgx.forEach(entry => {
                    lgxData.push(lgxHeaders.map(h => entry[h] || ''));
                });
                const lgxSheet = XLSX.utils.aoa_to_sheet(lgxData);
                XLSX.utils.book_append_sheet(wb, lgxSheet, 'LGX_Panel');
            }
            
            // Add connections sheet
            if (network.connections.length > 0) {
                const connHeaders = ['cableIn', 'fiberIn', 'port', 'tier', 'fiberOut', 'cableOut', 'type'];
                const connData = [connHeaders];
                network.connections.forEach(conn => {
                    connData.push(connHeaders.map(h => conn[h] || ''));
                });
                const connSheet = XLSX.utils.aoa_to_sheet(connData);
                XLSX.utils.book_append_sheet(wb, connSheet, 'Connections');
            }
            
            // Add utilization sheet
            const metrics = calculateUtilizationMetrics(network);
            const utilData = [
                ['Utilization Report'],
                [''],
                ['Overall Network'],
                ['Total Fibers:', metrics.totalFibers],
                ['Lit Fibers:', metrics.litFibers],
                ['Dark Fibers:', metrics.darkFibers],
                ['Utilization %:', metrics.utilizationPercent.toFixed(1) + '%'],
                [''],
                ['By Cable Type']
            ];
            
            Object.keys(metrics.byType).forEach(type => {
                const data = metrics.byType[type];
                utilData.push([type + ':', `${data.lit}/${data.total}`, ((data.lit/data.total)*100).toFixed(1) + '%']);
            });
            
            utilData.push([''], ['By FDA']);
            Object.keys(metrics.byFDA).forEach(fda => {
                const data = metrics.byFDA[fda];
                utilData.push([fda + ':', `${data.lit}/${data.total}`, ((data.lit/data.total)*100).toFixed(1) + '%']);
            });
            
            const utilSheet = XLSX.utils.aoa_to_sheet(utilData);
            XLSX.utils.book_append_sheet(wb, utilSheet, 'Utilization');
            
            // Export workbook
            XLSX.writeFile(wb, `Phoenix_Fiber_Network_${new Date().toISOString().split('T')[0]}.xlsx`);
            
            showNotification('Export Complete', 'Network data exported to Excel', 'success');
        }
        
        // =====================================================================
        // KEYBOARD SHORTCUTS & HELPERS
        // =====================================================================
        function handleKeyboardShortcuts(e) {
            // Ctrl+Z for undo
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            
            // Ctrl+Y for redo
            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
            
            // Ctrl+S for save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveProject();
            }
        }
        
        function saveHistoryState() {
            const state = {
                cables: collectGridData('cable'),
                splices: collectGridData('splice'),
                cabinets: collectGridData('cabinet'),
                msts: collectGridData('mst'),
                lgx: collectGridData('lgx')
            };
            
            // Remove future states if we're not at the end
            if (HISTORY_INDEX < HISTORY_STACK.length - 1) {
                HISTORY_STACK.splice(HISTORY_INDEX + 1);
            }
            
            HISTORY_STACK.push(state);
            
            // Limit history size
            if (HISTORY_STACK.length > MAX_HISTORY) {
